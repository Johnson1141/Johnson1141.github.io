<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[dp专题总结]]></title>
    <url>%2F2018%2F08%2F19%2Fdp%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[dp专题总结 所有的dp关键有两点1.看出来这是一道dp题 （看时间复杂度）2.状态转移方程！！！！其中状态的确立和推出状态转移方程是个难点,而且dp题还经常会和其他知识点融合在一起搞你，非常灵活。先从有迹可循的一些经典dp问题入手 一.数位dp1.确立状态如何确立一个正确的dp数组？dp[pos][state1][state2][….]首先第一维代表着数位若是人为规定的话： 0-个位 1-十位 2-百位 3……那么后面的state代表的就是 所有的的i位数满足的性质eg. 如果要记录所有四的倍数的数量 （当然有更简单的容斥做法，这里只是举个例子）开 dp[pos][mod]那么dp[3][2]代表着所有千位数（0000-9999）中%4余2的个数 那怎么确定我们要开那些状态？1.题目中明确要求的2.影响状态转移的（前导0什么的）例如 http://acmoj.shu.edu.cn/problem/65/每组数据只有一行，包含三个整数 L_i,R_i,m。在 [L_i,R_i ] 区间，有多少个数奇偶和等于 m，以及这些数的和（对和取模100000007后输出）。 和 http://hihocoder.com/problemset/problem/1033描述给定一个数 x，设它十进制展从高位到低位上的数位依次是 a0, a1, …, an - 1，定义交错和函数：f(x) = a0 - a1 + a2 - … + ( - 1)n - 1an - 1例如：f(3214567) = 3 - 2 + 1 - 4 + 5 - 6 + 7 = 4给定 l, r, k，求在 [l, r] 区间中，所有 f(x) = k 的 x 的和，即： 这两道题非常像，但是不同的地方导致我们的状态方程也不一样。先考虑第一道题:对于pos位,我们想要得到答案dp[pos][sum] 只需从dp[pos-1][sum-sgn*i]转移而来，用代码来表示的话，就是：12345678910for(int i=0; i&lt;=up; i++) &#123; int val; if(i&amp;1) val=i*(-1); else val=i; node tmp=dfs ( pos-1, m - val, limit &amp;&amp; i == up); ans.num += tmp.num; ans.sum=(ans.sum+i*POW[pos]%mod*tmp.num%mod +tmp.sum)%mod; &#125; dp[pos][sum]:pos位数中满足奇偶和是sum的个数与其总和我们只需开多开一维sum记录 pos位数中满足奇偶和是sum的个数当前的加减与当前的i有关，与之前和之后的数无关，转移并不会冲突。 第二道题：我们能否也和上一题一样也开 dp[pos][sum]呢？那好，先来解释一下 如果只开两维 dp数组的意义：pos位数满足交错和为sum时的个数和总和乍一看没问题，但当你写状态转移的时候，就会发现状态该怎么转移？状态没法转移，当前是加，那么下一位就是减，反之亦然。你没有办法区分当前是正是负 还是前导0，当前状态的不同会导致之后状态也不一样。所以给每个数再加上个性质：当前位的符号dp[pos][sum][sgn]sgn: 0-有前导0 ,1-正, -1 负 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct node&#123; LL num,sum;&#125;dp[30][500][3]; //偏移量240//第三维代表leadint a[30];LL Pow[30];int k;//lead 0-有前导0 1-正 -1 负node dfs(int pos,bool limit,int lead,int sum)&#123; if(pos==-1)&#123; return node&#123;sum==0,0&#125;; &#125; if(!limit&amp;&amp; dp[pos][sum+240][lead].num!=-1) return dp[pos][sum+240][lead]; node ans=node&#123;0,0&#125;; int up=limit?a[pos]:9; for(int i=0;i&lt;=up;i++) &#123; //处理前导0 int sgn=1; if (lead==0 &amp;&amp; i==0) sgn=0; else if(lead==0 &amp;&amp; i!=0) sgn=1; else sgn=-lead; node tmp=dfs(pos-1,limit&amp;&amp;i==up,sgn,sum-sgn*i); LL num=tmp.num,sum=tmp.sum; (ans.num+=tmp.num)%=mod; ans.sum+=Pow[pos]*i %mod *num %mod+ sum; ans.sum%=mod; &#125; return limit?ans:dp[pos][sum+240][lead]=ans;&#125;LL solve(LL x)&#123; if(x==-1) return 0; int pos=0; while(x)&#123; a[pos++] = x%10; x/=10; &#125; return dfs(pos-1,1,0,k).sum;&#125; 其他难以确立的状态还有很多，比如大都会的四维dp，比如各种模数，连续字串。但最为关键的就是记住dp[pos][state1][state2][…]每多一个状态，那么就是pos位的数进一步被细分，可以看做是各种性质的交集，怎么去分这个数，就是确立状态的关键。 2.状态的转移其实状态的转移多多少少要在确立这个状态的时候一并考虑到了，毕竟状态要能正确的转移，我们才能说这个确立的状态是对的嘛。而数位dp的转移是比较单纯的，因为多半就是从高位到地位枚举，从低位到高位转移，而我们一般都是用数位dp记录满足条件数的个数，转移比较简单，写出dp数组，一般转移就出来了。那如果要记录所有满足条件数的总和，平方和，别的什么奇奇怪怪的东西呢？额，目前就遇到过 和 与 平方和。和：当前枚举的数×当前的位权×（要转移到的）低位的满足某性质的个数+（要转移到的）低位的满足某性质的个数eg：$ \cdots x \cdots $令$x_1~x_n$都是满足条件的低一位的数$ sum = （x+x_1）+(x+x_2)+ \cdots (x+x_n) =n*x + x_1+\cdots+x_n$开个struct 记录num和sum 平方和： $ ans = (x+x_1)^2 + (x+x_2)^2 + \cdots + (x+x_n)^2 $ &emsp;&emsp; $ =n*x^2+2x(x_1+x_2+ \cdots +x_n)$ 所以要维护三个值：个数 总和 平方和 eg https://vjudge.net/contest/70324#problem/J 二概率dp（期望dp）感觉都可以用数学简化，但数学功底不够，就用dp来凑]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 多校赛一]]></title>
    <url>%2F2018%2F07%2F31%2F%E7%89%9B%E5%AE%A2-%E5%A4%9A%E6%A0%A1%E8%B5%9B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ALGV算法 抄一波 牛客的解释 （wiki 没耐心看了）作者：zzuzxy链接：https://www.nowcoder.com/discuss/87452?type=101&amp;order=0&amp;pos=1&amp;page=1LGV 算法 (Lindström–Gessel–Viennot lemma)求以上矩阵的行列式，其中 e(a,b) 是从a到b的方法数，带入求行列式即可得到(a1,a2,…an) 到 (b1,b2,…bn) 的所有不相交路径的种数再看这道题，其实就是要找从(n,0)到（0,m）的两条可重合的路径。如何将模型转移到不相交？一条路往左下角移一格a1,a2 ——- (n,0) (n-1,-1)b1,b2——— (0,m) (-1,m-1)e(a1,b1) = ….……ans= B Symmetric Matrix很有意思，从矩阵—关联到邻接矩阵（图论）—dp最终转换得到的题意是：给你n个不同的点，问能组成多少不同的环先考虑n个不同的球能组成多少不同的一个环 即：环排列 （n-1）!dp我是想不到的，那就走一遍吧：dp[n] 为数量为n的情况下，有多少的环的情况1.从n-1个点里找出1个点 与新加的点组成一个环(n-1)dp[n-2]2.从n-1个点中找出k个点 ，与新加的那个点组成一个环C(n-1,k) dp[n-k-1](k-1)!……………………………….死活推不出。。。这一数学题。老姐推出的。不贴代码了 就照着公式写f(n) = (n-1) f(n-2) +sum{k从2-(n-2)} ((n-1)!*f(k)/k!/2) E 大意：对于一个长度为 n 的由（1-k）组成的序列，去掉m个字符的不同子序列有多少个？ 由去掉m个字符组成子序列可以理解为只取（n-m）个字符组成的不同序列。首先遇到的问题是什么？同一个字符串可以有多种取法，那么如何筛除重复，就是这个问题的关键。1官方题解写的很不错。用dp做dp[i][j] 代表取第i个位置的数，且其中删除了j个数的情况数再去计算next[i][c] 代表第i个位置之后 第一个为c的位置（不包括位置i，且若是没有，统一为n+1）那么这样一来状态转移方程就是什么啊？dp[next[i][c]] [ next[i][c]-i-1+j ] +=dp[i][j]解释一下（我自己都看了好久。。。人蠢就要多努力）对于一串原序列与子序列：例如 原 1 2 1 2 1 1 2 1 子 1 1 2 （dp[4][1] ——-删了位置2） 对于 子序列 1 1 2 它下一个的取值有4种情况 恰好是pos 5~8，但是若是m=1（只删除一个）的话，pos 5，6，8就会多次记录，所以不能从位置四一一转移到 5 6 8，只能留一个，留哪个？很显然，留5，它是第一个出现的“1”，它的末尾可以接更多的值，就像直播时的前辈说的那样，这个有点贪心的感觉。如何去重的呢？看例子的位置 5 dp[5][0]=2 (11和21）怎么得到的11和21呢？位置是35和45只考虑这个数之前的第一个值。2之后看牛客别人的代码，发现大多数人不是这样做的，他们是如何处理的呢？dp[i][j]代表前i个位置，删j 个数的情况数（注意，这里不强制要求第i个数必须取，所以答案直接就是dp[n][m]）转移方程：dp( i , j ) = dp( i-1, j) +dp ( i-1, j-1) //第i个数不取+第i个数取显然，这里会有重复，我很好奇，他们是怎么处理重复的？if(pre[i]&amp;&amp;pre[i]+j-i&gt;=0) dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;额？这波操作有点秀啊，看不懂啊！！不过怎么这么熟悉呢if(pre[i]&amp;&amp;i-pre[i]&lt;=j)//如果位置i的前一个位置的数存在，并且能删那么多数 dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;举例子：1 2 3 4 3 3 2 1到pos 5 就有问题了 序列123 13 23就会有重复了假设在pos5前dp[i][j] 一直保持它原本的意义 那么根据转移式dp[5][0] 没重复，不用减dp[5][1]没重复，不用减dp[5][2]重复出现了 且减去 dp[2][1] （对应123）dp[5][3] 减去 dp[2][2] （对应12，13 ）dp[5][4]…….都减去一个0（因为dp越界了）好神奇啊 为什么啊？有什么神奇的，就是字面意思嘛首先要减去的这个dp值的位置肯定是pre[i]-1因为之后才确定是哪个3嘛那j是多少呢 pre[i]+j-i 即 j -（ i-pre[i] ）中间都不删啊,(有中间的元素的话，就是一个新序列了嘛)3还有一种做法ans[len] 代表长度为len的序列种数nxt[len][num]代表长度为len，之后数字为num的种数那么 ans[len] += ans[len]-1 - nxt[len][a[i]]dp[i][j] = ans[j-1]//额 看不懂了，贴一下代码之后消化吧1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define N 2000050using namespace std;typedef long long LL;const int MAX=1e5+10;long long dp[MAX][20];const int MOD= 1e9+7;long long ans[MAX];long long a[MAX];int main()&#123; int n,m,k; while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;k))&#123; for(int i=1;i&lt;=n;i++)&#123; ans[i]=0; memset(dp[i],0,sizeof dp[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; ans[0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&gt;=1 &amp;&amp; j&gt;=i-m-1;j--)&#123; ans[j]=(ans[j]+ans[j-1]-dp[j][a[i]])%MOD; dp[j][a[i]]=ans[j-1]; &#125; &#125; ans[n-m]=(ans[n-m]+MOD)%MOD; cout&lt;&lt;ans[n-m]&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin专题 搜索]]></title>
    <url>%2F2018%2F07%2F18%2Fkuangbin%E4%B8%93%E9%A2%98-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[E醉了，说有100位的十进制数，我想那会炸的啊，没想到啊，所有的答案都在long long范围内，那时候应该打个表看看 Fbfs 水题 G模拟题 怎么就搜索了？？没做 Hbfs + 记录路径怎么记录路径？记录每个点的前驱，像并查集那样向上跳，就是所求的路径。但这里有一个问题，它要准确打印操作是什么（我猜）就两个解决方法1：记录下来 就结构体里多加点东西咯2：打印答案路径的时候，对比v与前驱pre[v]，判断是什么我这里用了第二种方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;typedef pair&lt;int, int&gt; PII;int vol1,vol2,n;map &lt;PII,int &gt; vis;map &lt;PII,PII&gt; pre;int num;void ok()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;void dfs(PII tmp)&#123; if(pre.find(tmp)!=pre.end()) &#123; num++; dfs(pre[tmp]); int u1=tmp.X,v1=tmp.Y; int u2=pre[tmp].X,v2=pre[tmp].Y; if(u1+v1==u2+v2)&#123; cout&lt;&lt;"POUR("; if(u1&gt;u2) cout&lt;&lt;"2,1"; else cout&lt;&lt;"1,2"; cout&lt;&lt;")"&lt;&lt;endl; &#125; else if(u1==vol1&amp;&amp;u2!=vol1) cout&lt;&lt;"FILL(1)"&lt;&lt;endl; else if(v1==vol2&amp;&amp;v2!=vol2) cout&lt;&lt;"FILL(2)"&lt;&lt;endl; else if(u1==0&amp;&amp;u2!=0) cout&lt;&lt;"DROP(1)"&lt;&lt;endl; else if(v1==0&amp;&amp;v2!=0) cout&lt;&lt;"DROP(2)"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;&#125;int main()&#123; while(cin&gt;&gt;vol1&gt;&gt;vol2&gt;&gt;n) &#123; vis.clear(); queue&lt;PII&gt; q; q.push(PII(0,0)); int finish=0; while(!q.empty()) &#123; PII tmp=q.front(); vis[tmp] = 1; q.pop(); int u=tmp.X,v=tmp.Y; if(u==n||v==n) &#123; num=0; dfs(tmp); finish=1; break; &#125; //三个操作 六种情况 int uu,vv; uu=vol1,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=vol2; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=0,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=0; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=min((u+v),vol1),vv=u+v-uu; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; vv=min((u+v),vol2),uu=u+v-vv; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; &#125; if(!finish) &#123;puts("impossible");continue;&#125; &#125; return 0;&#125; I - Fire Game FZU - 2150又一个神奇的oj 没c++11我写的好不习惯。不过这题还不错，让我折腾了好久。几个点：1.永远注意数据范围虽然数据小不意味着就要暴力，但这道题太tm小了，想用巧妙的方法做错了啊2.要用vis数组的话，push前就更新比较保险3.bfs别忘了pop，虽然总能debug出来，但好浪费时间啊，你就给我注意一下啊题本身倒没什么，暴力跑bfs就可以了，吐槽一下 n^6我tm写了四个循环，这怎么看都要t了，奈何不住数据小啊tips：看到一个优化在枚举的时候 第三重和第四重可以不用从0枚举12for(int ii=0;ii&lt;n;ii++) ==》 for(int ii=i;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) ==》 for(int jj=i==ii?j:0;jj&lt;m;jj++) 看大佬的代码 至于为什么。。。，容我三思 额，其实就是因为如果每行从自己开始的话会漏掉前面的一些点 或者干脆只优化一行，时间也没差多少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef unsigned long long LL;typedef pair&lt;int,int&gt; PII;const int INF = 0x3f3f3f3f;const double eps = 1e-6;int n,m;char G[20][20];int vis[20][20];int dis[20][20];int res;int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;inline bool check(int x,int y)&#123; return x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;G[x][y]=='#';&#125;void bfs(int x1,int y1,int x2,int y2)&#123; queue&lt;PII&gt; q; clr(vis,0); clr(dis,0); q.push(PII(x1,y1));vis[x1][y1]=1; q.push(PII(x2,y2));vis[x2][y2]=1; int ans=0; while(!q.empty())&#123; PII u=q.front(); q.pop(); ans=dis[u.X][u.Y]; for(int i=0;i&lt;4;i++)&#123; int xx=u.X+dx[i],yy=u.Y+dy[i]; if(check(xx,yy)&amp;&amp;!vis[xx][yy]) &#123; vis[xx][yy]=1; dis[xx][yy]=ans+1; q.push(PII(xx,yy)); &#125; &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#'&amp;&amp;!vis[i][j]) return ; res=min(res,ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int k=1;k&lt;=t;k++)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",G[i]); res=INF; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#') for(int ii=0;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) if(G[ii][jj]=='#') &#123; bfs(i,j,ii,jj); &#125; if(res==INF) res=-1; printf("Case %d: %d\n",k,res); &#125;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>搜索</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180717SHU暑期集训训练赛(6)===]]></title>
    <url>%2F2018%2F07%2F17%2F20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B-6%2F</url>
    <content type="text"><![CDATA[B D E K L是看过的题但没过 B蔡老师强啊 样例看了好久看不懂，磨到晚上蔡老师才指点迷津先解释样例1 2 有三组 就是3C2=3（1 2 ，3 1）和（3 1，1 2）为一组（1 2，1 2，3 1）和（1 2，3 1，1 2）为一组加起来五组 （这道题看似图论，跟图论没半毛钱关系）之前不小心看到题解了是hash，还是两次hash，怎么搞？想一想。想不出啊。让我猜猜看，边hash成一个值，多条边再hash成一个值？？不对啊 老哥额 还要一个公式 (n+1)C2 - nC2 = n就是说每加入一个新的值 ans都要加上 原有个数（注意不是n+1是n）相同值的hash值相加一样没问题，但不同的数的hash值相加会不会也一样？应该不一样把，人家都过了这道题了，hash不就是解决这个问题的嘛，不清楚，没学过。双hash函数 保证没有例外12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1&lt;&lt;12;//两个hash函数 所需seed 和 pLL seed1=13131313,seed2=23333333,mod1=1e9+7,mod2=1e9+9;LL p1[N],p2[N];map &lt;pair&lt;int,int&gt;,LL&gt; id;int a[N];map&lt;pair&lt;int,int&gt;,LL&gt; cnt[N];int main()&#123; p1[0]=p2[0]=1; for(int i=1; i&lt;N; i++) p1[i] = p1[i-1] * seed1 % mod1; for(int i=1; i&lt;N; i++) p2[i] = p2[i-1] * seed2 % mod2;//这两步的意义是处理什么？写hash函数 fastin int t; cin&gt;&gt;t; while(t--) &#123; id.clear(); int n; cin&gt;&gt;n; for(int i=0,x,y; i&lt;n; i++) &#123; //将边hash成一个id值 cin&gt;&gt;x&gt;&gt;y; if(x&gt;y) swap(x,y); if(id.find(&#123;x,y&#125;)==id.end()) id[&#123;x,y&#125;] = id.size(); a[i] = id[&#123;x,y&#125;] ; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) cnt[i].clear(); for(int i=0; i&lt;n; i++) &#123; LL sum1=0,sum2=0; for(int j=i; j&lt;n; j++) &#123; (sum1+= p1[a[j]]) %=mod1; (sum2+= p2[a[j]]) %=mod2; ans+=cnt[j-i][ &#123;sum1,sum2&#125;]; //厉害啊 想不到 cnt[j-i][ &#123;sum1,sum2&#125;]++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 半抄半做的题，到时候再重新做一下 D The main idea is that we only need to keep track of the number of active cells and the last strictly increasing sequence of powers from right to left, this is because if we have a cell with number X and the cell to the right has number Y where Y &gt; X , these two cells will never merge and therefore anything to the left of them won’t add anything to the score so we don’t need to keep track of them.This leads to a DP Bitmask solution where we store the bitmask of available powers of 2 (they are guaranteed to be strictly increasing from right to left because we ignore any powers that aren’t) and the number of active cells (free cells + number of bits in the mask).If the current mask is msk and a 4 is generated, the new mask will become msk + 4 and ((msk)^(msk + 4)) - 4 will be added to the score.When a 2 is generated, the new mask will become msk + 2 and ((msk)^(msk + 2)) - 2 will be added to the score.The added score explained above is the score added from all the merge operations that will happen after adding the new number, not only the first one. Merging them all at once will not affect the final answer.^ is the bitwise XOR operator. 毫无头绪，不好意思英文的题解，慢慢啃吧尽力了 下一道E。。。。下一道 K生成树 ，李老师说的对啊，我错了先找到环上的任意一条边，去掉它，这张图就成为一个树了那么不考虑去掉的那条边，就是一个lca问题。只是在这里没有那么简单，要考虑经过那条边的情况，无非多出两种情况总共三种情况 1.不经过u—-v lcm //不经过去掉的边2.从u到v w+x—u+y—v3.从v到u w+x—v+y—u 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1e5+10;struct edge&#123; int to; LL w;&#125;;vector&lt;edge&gt; G[N];int father[N];int Find(int x)&#123; return x==father[x] ? x : father[x]=Find(father[x]);&#125;void Union(int x,int y)&#123; int rx=Find(x),ry=Find(y); if(rx==ry) return ; father[rx]=ry;&#125;//lca 一dfs处理深度 和faint dep[N],fa[N][30];LL d[N];//i到1的距离int n,q;void dfs(int u,int pre,LL dis)&#123; fa[u][0]=pre; d[u] = dis; for(auto tmp:G[u]) &#123; int v=tmp.to; LL distance=tmp.w; if(v!=pre) &#123; dep[v]=dep[u]+1; dfs(v,u,d[u]+distance); &#125; &#125;&#125;void bz()&#123; for(int j=1; j&lt;=29; j++) for(int i=1; i&lt;=n; i++) fa[i][j] = fa[fa[i][j-1]][j-1];&#125;void LCAinit()&#123; clr(dep,0); dep[1]=1; clr(d,INF); dfs(1,0,0); bz();&#125;int LCA(int u,int v)&#123; if(dep[u]&gt;dep[v]) &#123; swap(u,v); &#125; int cha = dep[v] - dep[u]; int len = log2(n); for(int x=0; x&lt;=len; x++) if((1&lt;&lt;x)&amp;cha) v=fa[v][x]; if(u==v) return u; for(int x=len; x&gt;=0; x--) &#123; if(fa[v][x]!=fa[u][x]) &#123; u=fa[u][x]; v=fa[v][x]; &#125; &#125; return fa[u][0];&#125;LL dis(int x,int y)&#123; int c=LCA(x,y); return d[x]+d[y]-2*d[c];&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; for(int i=0;i&lt;=n;i++) G[i].clear(); scanf("%d%d",&amp;n,&amp;q); for(int i=0; i&lt;=n; i++) father[i]=i; int in,out,w; for(int i=0,x,y; i&lt;n; i++) &#123; LL val; scanf("%d%d%lld",&amp;x,&amp;y,&amp;val); if(Find(x)==Find(y)) &#123; in=x,out=y,w=val; &#125; else &#123; Union(x,y); G[x].push_back(edge&#123;y,val&#125;); G[y].push_back(edge&#123;x,val&#125;); &#125; &#125; LCAinit(); for(int i=0,x,y; i&lt;q; i++) &#123; scanf("%d%d",&amp;x,&amp;y); LL ans=dis(x,y); ans=min(ans,dis(x,in)+dis(out,y)+w); ans=min(ans,dis(x,out)+dis(in,y)+w); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716SHU暑期集训组队赛(5)===]]></title>
    <url>%2F2018%2F07%2F16%2F20180717SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E7%BB%84%E9%98%9F%E8%B5%9B-5%2F</url>
    <content type="text"><![CDATA[又tm垫底了两道图论+二分答案没过模板 迪杰斯特拉最短路 + 二分答案 二分图匹配+二分答案特点：最大化其中最小值（最小化其中最大值）多源bfs？最小化最远距离（对于状态而言） https://vjudge.net/contest/237325#problem/D（）先打两个模板压压惊，去洛谷啊 E dij+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const LL INF = LL(1)&lt;&lt;50;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=500010;struct node&#123; int x; LL val; bool operator &lt; (const node&amp;a)const &#123; return val&gt;a.val; &#125;&#125;;vector&lt;node&gt; G[N];int vis[N];LL dis[N];int n,m,x;int mz;bool Dij(LL lim)&#123; clr(vis,0); for(int i=0;i&lt;=n;i++) dis[i]=INF; priority_queue&lt;node&gt; q; dis[1]=0; q.push(node&#123;1,0&#125;); node tmp; while(!q.empty()) &#123; tmp=q.top(); q.pop(); int u=tmp.x; if(vis[u]) continue; vis[u]=1; for(auto nd:G[u]) &#123; int v=nd.x; LL cost=nd.val; if(cost &gt; lim) continue; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; q.push(node&#123;v,dis[v]&#125;); &#125; &#125; &#125; if(dis[n]&lt;=mz) return true; return false;&#125;void showg()&#123; for(int i=1;i&lt;=n;i++)&#123; for(auto v:G[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.val; cout&lt;&lt;endl; &#125;&#125;int main()&#123; fastin cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=0,u,v;i&lt;m;i++)&#123; LL dis; cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis; G[u].push_back (node&#123;v,dis&#125;); G[v].push_back (node&#123;u,dis&#125;); &#125; Dij(1e7); mz=dis[n]*(1.0+x/100.0); LL l=0,r=INF; while(r-l&gt;1)&#123; LL mid=l+(r-l)/2; if( Dij(mid) ) r=mid; else l=mid; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; J 二分图匹配+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=5010;const int M=50010;vector&lt;int&gt; G[N];int link[N],used[N];int n,m;int uN;bool dfs(int u)&#123; for(auto v:G[u]) &#123; if(!used[v]) &#123; used[v]=1; if(link[v]==-1||dfs(link[v])) &#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res=0; memset(link,-1,sizeof link); for(int u=1; u&lt;=uN; u++) &#123; clr(used,0); if(dfs(u)) res++; &#125; return res;&#125;int dis[110][110];bool judge(int lim)&#123; for(int i=0; i&lt;=n; i++) G[i].clear(); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(dis[i][j]&lt;=lim) &#123; G[i].pb(j+n); G[j+n].pb(i); &#125; return hungary()==n;&#125;int xx[240];int yy[240];int main()&#123; fastin cin&gt;&gt;n; uN=n; for(int i=1; i&lt;=2*n; i++) &#123; cin&gt;&gt;xx[i]&gt;&gt;yy[i]; &#125; for(int i=1; i&lt;=n; i++) for(int j=n+1; j&lt;=2*n; j++) dis[i][j-n] = abs(xx[i]-xx[j])+abs(yy[i]-yy[j]); int l=0,r=1e8; while(r-l&gt;1) &#123; int mid=l+(r-l)/2; if(judge(mid)) r=mid; else l=mid; //cout&lt;&lt;mid&lt;&lt;endl; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; 二分答案题感觉都是00000000000001111111111111111111（求第一个1）或11111111111111110000000000000000（求第一个0）而不能解决 类似于0111111000011111000011111000000（求第一个0）记住就好了 G大意：有多个点，对于每个点，给定它的坐标和曼哈顿半径，求有几个交点0个就impossible 1就输出那个交点 2就uncertain最多 4e61+1e6 1000好气啊 当时都想出来了 复杂度推错了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;struct node&#123; int x,y; bool operator&lt; (const node&amp;a)const &#123; return x&lt;a.x; &#125;&#125;;vector&lt;node&gt; st[2];int main()&#123; fastin int n;cin&gt;&gt;n; int x,y,dis;cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(int i=-dis;i&lt;=dis;i++)&#123; st[0].push_back(node&#123;x+i,y+dis-abs(i)&#125;); if(i!=-dis &amp;&amp; i!= dis) st[0].push_back(node&#123;x+i,y-dis+abs(i)&#125;); &#125; int flag=1; for(int i=1;i&lt;n;i++)&#123; st[flag].clear(); cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(auto v:st[1^flag]) if(abs(x-v.x)+abs(y-v.y)==dis) st[flag].push_back(node&#123;v.x,v.y&#125;); flag^=1; &#125; flag^=1; /* for(int i=0;i&lt;2;i++)&#123; for(auto v:st[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.y&lt;&lt;endl; cout&lt;&lt;endl; &#125; */ if(st[flag].size()==1) cout&lt;&lt;st[flag][0].x&lt;&lt;" "&lt;&lt;st[flag][0].y&lt;&lt;endl; else if(st[flag].size()==0) puts("impossible"); else puts("uncertain"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑期集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716 SHU暑期集训个人赛(3)===]]></title>
    <url>%2F2018%2F07%2F16%2F%3D%3D%3D20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B(3)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[垫底之旅2016-2017 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2016) 看的题 但没做出来 感觉都在能力范围之内 就是没想到 A倒跑并查集也蛮难写的 也要把一个点hash成一个值 就是二维变一维嘛这 怎么想的到 Btire树上的bfstire树都不知道是是什么 你让我怎么做 C对一副乱序的扑克牌求排有序的最小_交换相邻元素的_操作个数首先数据规模很小 （最多52张牌嘛）先想想最暴力的做法咯 就对于给定的一副牌排序的结果无非是 4!（花色全排列）*2^4（顺序和倒序）种结果 384例如样例12h Th 8c Qh所有的可能性 1.2h Th Qh 8c 2.8c 2h Th Qh还有倒序的，不写了那验证每一种初态到给定态的检查的方法复杂度要多少啊？不知道啊 卡住了啊 看题解。。。怎么就LCS了拉 我怎么不知道什么意思啊？那就考虑一个更简单的模型一串乱序的数字序列 需要相邻元素交换几次才能变为不下降序列？额 不需要相邻元素 随便交换 又读错题了。。。。Sorting is done by moving one card at a time fromits current position to a new position in the hand, atthe start, end, or in between two adjacent cards. Whatis the smallest number of moves required to sort agiven hand of cards?枚举4！种排列组合 和2^4 正序 倒序 暴力求解求出最大的LCS就可以拉有个小tips：A是王牌 是最大的。。。。wa了好几发 读题读题看错题太蠢了 F推公式 排列组合题 ，没什么难度 但我推不出 H见过一道差不多的，没去写，亏了。找了半个小时没找到 算了。额 我错了 看了那么久 还是看不懂抄一遍代码 找感觉吧额 又看了一遍题目。知道了，感觉有意思。大意是：给n个矩形，让他们一个一个往上叠，约束条件是 宽严格递减（矩形可以旋转，所以长宽可以交换），求最大高度。（n个矩形都要用到）1，建图。当时第一步都没想到，鬼知道要长宽相连建图啊，但其实应该知道，这已经不是第一次遇到了。（第二次）建图前想一想，该怎么建图，如果单纯相连，那图的意义，边的意义，点的意义是什么？这里主要是边的意义,认为规定 a-&gt;b的有向边是这个矩形啊 a为宽，b为高放置。（鬼才想的到，我想不到。）利用约束条件有对这个图产生了新的限制：一个点最多一个出度（这个点只能做一次宽）这个图可能有许多连通分支，就挑一个来看，这个连通分支有什么特点2，已知：输入保证n个矩形能叠起来那上界，n个点是不是最多n条边？ 额，不知道。证明一下咯，如果有n+1条边，至少一个点的出度&gt;=2.有n条边，那连通分支中有一个环，再加一条边，又多一个环，就是说，n+1条边的无向图中有两个环一个环已经自给自足了，没法有出度的边了，那只能别人进去，有两个别人需要进去的点（环缩点），那势必有一个点需要出度两次。===\1.png) 所以n个点的连通分支最多只有n条边。 考虑下界，n个点的连通分支最少有n-1条边（一棵树，真的不能再少了，再少就两个连通分支了。。。）所以只有两种情况，n个点n条边，每个点都出度一次n个点n-1条边，有一个点无需出（哪个点不用做宽啊，哪肯定是值最大的那个啊，给我滚去做高啊） 那怎么写啊。。。。。额 抄一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int N = 5e5;vector&lt;int&gt;G[N];int val[N];int vis[N];int sz=0;int maxv,deg;LL ans=0;map&lt;int,int&gt; id;void dfs(int u)&#123; vis[u]=1; deg+=G[u].size()-2; //妙啊 一条边贡献两个度数，要是树的话，只有2n-2个总度数 ans+=LL(val[u])*(G[u].size()-1); maxv=max(maxv,val[u]); //维护最大点 for(auto v:G[u])&#123; if(!vis[v]) dfs(v); &#125;&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=0,x,y;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(id.find(x)==id.end()) id[x]=++sz,val[sz]=x; //缩点 if(id.find(y)==id.end()) id[y]=++sz,val[sz]=y; G[id[x]].pb(id[y]); G[id[y]].pb(id[x]); &#125; clr(vis,0); ans=0; for(int i=1;i&lt;=sz;i++)&#123; if(!vis[i]) &#123; maxv=0,deg=0; dfs(i); if(deg!=0) ans+=maxv; //是个树加上最大的那个点 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>倒跑</tag>
        <tag>字典树</tag>
        <tag>排列组合</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2018%2F07%2F16%2FLCS%2F</url>
    <content type="text"><![CDATA[给出两个串 ，输出最长公共子序列学习地址：https://blog.csdn.net/zhijianshafeiyang/article/details/45034853 “用一个数组将第一个串内元素在第二个串内的位置保存下来，求这个数组的最长上升子序列长度”什么叫第一个串内元素在第二个串内的位置？比如 str1 = avbasx str2 = abcaszx 位置是反序 就是 4，1——2——4，1——5——7eg2： aaba abaa 4 3 1 —— 4 3 1—— 2 —— 4 3 1 两个问题 1.记录位置 2.位置的反序 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100000;//---------------int ans[MAX];vector&lt;int&gt; a;int LIS()&#123; int len=1; ans[0]=a[0]; for(int i=1;i&lt;a.size();i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++] = a[i]; else *lower_bound(ans,ans+len,a[i]) = a[i]; &#125; return len;&#125;//--int a1[MAX],a2[MAX];int LCSlen1,LCSlen2;int LCS()&#123; map&lt;int,int&gt; pos; a.clear(); for(int i=0;i&lt;LCSlen1;i++)&#123; pos[a1[i]] = i; &#125; for(int i=0;i&lt;LCSlen2;i++)&#123; if(pos.find(a2[i])!=pos.end()) a.pb(pos[a2[i]]); &#125; return LIS();&#125; 区域赛更新1234567891011121314int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180619 SHU暑期集训个人赛(1)]]></title>
    <url>%2F2018%2F06%2F19%2F%3D%3D%3D20180619SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E4%B8%AA%E4%BA%BA%E8%B5%9B(1)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[A - Subarrays BeautyGym - 101532A 找规律 注意位运算 多半是对位的找规律 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[100010];LL b[100010];int n;LL func(LL x)&#123; return x*(x+1)/2;&#125;LL coun()&#123; LL num=0; LL ans=0; for(int i=0;i&lt;n;i++)&#123; if(num&gt;0&amp;&amp;b[i]==0) &#123; ans+=func(num);num=0; &#125; if(b[i]==1) num++; &#125; ans+=func(num); return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);LL _max=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]);_max=max(_max,a[i]); &#125; int wei=log2(_max); wei+=2; LL ans=0; LL basic=1; for(int i=0;i&lt;wei;i++,basic&lt;&lt;=1)&#123; for(int j=0;j&lt;n;j++)&#123; b[j]= a[j]&amp;1; a[j]&gt;&gt;=1; &#125; ans+=basic*coun(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;/*237 11 9411 9 6 11*/ B - Array Reconstructing Gym - 101532B 简单题 我都记不清是什么题了 多半是尝试 打印答案 //想起华师的第二道题 妈的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[1010];int n;void print_ans(int x,LL val,LL m)&#123; for(int i=x+1;i&lt;n;i++)&#123; a[i]=(a[i-1]+1)%m; &#125; for(int i=x-1;i&gt;=0;i--)&#123; a[i]=(a[i+1]-1+m)%m; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; LL m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]!=-1) &#123;print_ans(i,a[i],m);break;&#125; &#125; return 0;&#125;/*45 101 2 3 4 54 107 -1 9 -16 75 -1 -1 1 2 36 105 -1 7 -1 9 0*/ C - Large Summation Gym - 101532C二分 没什么特殊的 没接触过罢了lower_bound() &gt;=upper_bound() &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;struct node&#123; int no; int val; int ans;&#125;;int n;node a[200100];bool cmp1(node a,node b)&#123; return a.val&lt;b.val;&#125;bool cmp2(node a,node b)&#123; return a.no&lt;b.no;&#125;int findkey(int val,int pos)&#123; int l=0,r=n-1; int mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(a[mid].val&gt;val) r=mid-1; else l=mid+1; &#125; if(r==pos) r--; if(r&lt;0) return a[(pos+1)%n].val; return a[r].val;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123;cin&gt;&gt;a[i].val;a[i].no=i;&#125; sort(a,a+n,cmp1); for(int i=0;i&lt;n;i++)&#123; int ans1; if(i==n-1) ans1=(a[n-2].val+a[n-1].val)%mod; else ans1=(a[n-1].val+a[i].val)%mod; int tmp=findkey(mod-a[i].val-1,i); int ans2=(a[i].val+tmp)%mod; a[i].ans=max(ans1,ans2); &#125; sort(a,a+n,cmp2); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i].ans&lt;&lt;" "; cout&lt;&lt;a[n-1].ans&lt;&lt;endl; &#125; return 0;&#125;/*331 2 321000000000 10000000003500000007 500000002 500000003*/ D - Counting Test Gym - 101532D 预处理+查询注意l-r可以处理为 (1~r) - (1~l-1) 简单好多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[10010][26];char tmp;LL func(LL s,LL e)&#123; if(s==0) return a[e][tmp-'a']; return a[e][tmp-'a']-a[s-1][tmp-'a'];&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); memset(a,0,sizeof a); string s;cin&gt;&gt;s; a[0][s[0]-'a']++; for(int i=1;i&lt;n;i++)&#123; int num=s[i]-'a'; a[i][num]++; for(int j=0;j&lt;26;j++) a[i][j]+=a[i-1][j]; &#125; for(int i=0;i&lt;m;i++)&#123; LL ans=0; LL l,r;scanf("%lld %lld %c",&amp;l,&amp;r,&amp;tmp); l-=1;r-=1; if(r-l&lt;n)&#123; r%=n,l%=n; if(r&gt;=l) ans+=func(l,r); else&#123; ans+=func(l,n-1); ans+=func(0,r); &#125; &#125; else&#123; LL len1=r%n,len2=n-l%n; ans+=func(l%n,n-1); ans+=func(0,r%n); ans+=(r-l-len1-len2) / n * a[n-1][tmp-'a']; &#125; printf("%lld\n",ans); &#125; &#125;&#125;/*18 5abcabdca1 1 c1 15 b4 9 a5 25 d2 7 c*/ E - Game of Dice Gym - 101532E折半查找 第一次做 还可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const double eps = 1e-6;LL a[500][7];map&lt;LL,int&gt; c;int n;LL m;LL res=0;long long quickmod(long long a,long long b,long long m)&#123; long long ans = 1; while(b)&#123; if(b&amp;1)&#123; ans = (ans*a)%m;b--; &#125; b/=2; a = a*a%m; &#125; return ans;&#125;void dfs1(int cur,int e,LL ans)&#123; if(cur==e)&#123; ++c[ans]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs1(cur+1,e,(ans*a[cur][i])%mod); &#125;&#125;void dfs2(int cur,int e,LL ans)&#123; if(cur==e)&#123; res+=c[(m*quickmod(ans,mod-2,mod))%mod]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs2(cur+1,e,(ans*a[cur][i])%mod); //SDUSHADJKASDNJKASDHJK &#125;&#125;void init()&#123; res=0; c.clear();&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d %lld",&amp;n,&amp;m); init(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;6;j++) scanf("%lld",&amp;a[i][j]); int mid=n/2; dfs1(0,mid,LL(1)); dfs2(mid,n,LL(1)); cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; F - Strings and Queries Gym - 101532F 1.hash2.暴力枚举回文子串数量3.st处理区间问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int func(char s[])&#123; LL ans=0; int n=strlen(s); for(int i=0; i&lt;n; i++) &#123; for(int len=1; len&lt;n; len++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len]) ans++; else break; &#125; &#125; for(int i=0; i&lt;n-1; i++) if(s[i+1]==s[i]) &#123; ans++; for(int len=1; len&lt;n; i++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len+1]) ans++; else break; &#125; &#125; return ans;&#125;int c[40][40];int func1(string s)&#123; int len=s.size(); int sum=0; memset(c,0,sizeof c); for(int i=len-1; i&gt;=0; i--) &#123; c[i][i]=true; sum++; for(int j=i+1; j&lt;len; j++) &#123; if(s[i]==s[j]) &#123; if(i+1==j||c[i+1][j-1]) &#123; c[i][j]=true; sum++; &#125; &#125; else c[i][j]=false; &#125; &#125; return sum;&#125;LL Hash(string s)&#123; LL ans=0; int len=s.size(); for(int i=0; i&lt;len; i++) &#123; ans=ans*31+s[i]-'a'+1; &#125; return ans;&#125;struct node&#123; int no; int val; node(int n=0,int v=0) &#123; no=n; val=v; &#125; bool operator &lt; (const node&amp; a) const &#123; if(val==a.val) return no&gt;a.no; return val&lt;a.val; &#125;&#125;;char s[40];int n;node dp[10100][40];void st()&#123; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;node RMQ(int l,int r)&#123; int k=log2(r-l+1); return max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; map&lt;LL,int&gt; mp; int q; scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s); int num=func1(s); LL hs=Hash(s); mp[hs]=i; dp[i][0]=node(i,num); &#125; st(); for(int i=1; i&lt;=q; i++) &#123; char tmp1[40],tmp2[40]; scanf("%s",tmp1); scanf("%s",tmp2); LL hs1=Hash(tmp1),hs2=Hash(tmp2); int n1=mp[hs1],n2=mp[hs2]; if(n1&gt;n2) swap(n1,n2); printf("%d\n",RMQ(n1,n2).no); &#125; &#125; return 0;&#125;int main1()&#123; cout&lt;&lt;Hash("aaaa")&lt;&lt;endl; cout&lt;&lt;Hash("aaaaa")&lt;&lt;endl;&#125;/*35 5aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbcccaaaaccccaaaaaaaaaaaaaaaaccccccacccccc aaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa cccaaaaccccaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaacccccc aaaaaaaaaaaaa*/ G - Magical Indices Gym - 101532G 前缀 后缀 签到题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;int a[1000100];int maxtou[1000100];int minwei[1000100];int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i==0) maxtou[0]=a[0]; else maxtou[i]=max(maxtou[i-1],a[i]); &#125; minwei[n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--)&#123; minwei[i]=min(minwei[i+1],a[i]); &#125; int ans=0; for(int i=1;i&lt;n-1;i++)&#123; if(a[i]&lt;=minwei[i+1]&amp;&amp;a[i]&gt;=maxtou[i-1]) ans++; //cout&lt;&lt;a[i].index&lt;&lt;" "; &#125; printf("%d\n",ans); &#125; return 0;&#125;/*4101 2 1 1 1 1 1 1 1 153 3 4 5 3*/``` ## H - Corrupted Images Gym - 101532H 签到题注意角上的 唯一的坑点了吧```c++#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;char a[60][60];int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; int num=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='1') num++; &#125; if( num&lt;(2*n+2*m-4) ) &#123;cout&lt;&lt;"-1"&lt;&lt;endl;continue;&#125; int ans=0; for(int j=0;j&lt;m;j++)&#123; if(a[0][j]=='0') ans++; if(a[n-1][j]=='0') ans++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i][0]=='0') ans++; if(a[i][m-1]=='0') ans++; &#125; if(a[0][0]=='0') ans--; if(a[n-1][0]=='0') ans--; if(a[0][m-1]=='0') ans--; if(a[n-1][m-1]=='0') ans--; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; I - The Crazy Jumper Gym - 101532I dp注意下一个元素是要特殊处理 不然会超时一步步覆盖 从头想想从尾部会怎么样？12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int a[200110];int pos[200110];int dp[200110];int n;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); dp[0]=-1; memset(pos,0,sizeof pos); for(int i=1;i&lt;=n;i++)&#123; int val; scanf("%d",&amp;val); dp[i]=dp[i-1]+1; if(pos[val]!=0) dp[i]= min ( dp[i] , dp[ pos[val] ]+1); pos[val] = i ; &#125; printf("%d\n",dp[n]); &#125;&#125; J - The Hell Boy Gym - 101532J 公式 或者 递推数学问题12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9+7;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); LL ans=1,tmp; while(n--) &#123;scanf("%lld",&amp;tmp); ans=(ans*(tmp+1))%mod;&#125; printf("%lld\n",(ans+mod-1)%mod); &#125; return 0;&#125; K - Palindromes Building Gym - 101532K 组合数学123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int P[12];void pre()&#123; P[0]=1; for(int i=1;i&lt;=11;i++) P[i]=i*P[i-1];&#125;int main()&#123; pre(); int t;cin&gt;&gt;t; while(t--) &#123; int n;int l[26]; memset(l,0,sizeof l); cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char tmp;cin&gt;&gt;tmp; l[tmp-'a']++; &#125; int num=0; for(int i=0;i&lt;26;i++) if(l[i]&amp;1) num++; if(num&gt;=2)&#123; cout&lt;&lt;0&lt;&lt;endl;continue;&#125; int len=0; for(int i=0;i&lt;26;i++) &#123;l[i]/=2;len+=l[i];&#125; int ans=P[len]; for(int i=0;i&lt;26;i++) &#123;ans/=P[l[i]];&#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L - List Of Integers CodeForces - 920G 二分答案 之后容斥验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long long ll;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;void show()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;vector&lt;LL&gt; vec;LL cnum(LL r) //求1-r中与 k（不）互质 的元素的个数&#123; LL ans=0; int wei=vec.size(); for(LL i=1; i&lt;(1LL&lt;&lt;wei); i++) &#123; int bits=0,multi=1; for(LL j=0; j&lt;wei; j++) &#123; if(i&amp;(1LL&lt;&lt;j)) &#123; bits++; multi*=vec[j]; &#125; &#125; LL cur=r/multi; if(bits&amp;1) ans+=cur; else ans-=cur; &#125; //return ans; //返回与其不互质的元素个数 return r-ans;//返回与其互质的元素个数&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; LL l,no, p; scanf("%lld%lld%lld",&amp;l,&amp;p,&amp;no); vec.clear(); LL ans=0; for(LL i=2; i*i&lt;=p; i++) &#123; if(p%i==0) vec.push_back(i); while(p%i==0) p/=i; &#125; if(p&gt;1) vec.push_back(p); LL r=1e12; LL tmp=no+cnum(l); while(l&lt;=r) &#123; LL mid=l+(r-l)/2; if(cnum(mid)&gt;=tmp) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125; N - Sleepy GameCodeForces - 936B 三种简单图论知识的集合题 1.有向图 dfs判环 vis[] 标记 三种标记 0代表未访问 1代表正在访问这个分支 2代表访问完成某一分支 什么时候会形成环？ 这个点的分支在访问的时候又回到了自己这个点 蔡老师强啊 一般我会写 1234567891011121314bool huan(int u)&#123; bool flag=false; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1) return true; else if(c[v]==0)&#123; if(huan(v)) flag=true; &#125; &#125; c[u]=2; return flag;&#125; 又丑又长12345678910bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125; 对判环理解很深刻（&amp;&amp;与||优先级 不要怕 大胆写啊） 2.拆点一张图拆成两张图 偶数路径 奇数路径偶-奇-偶-。。。。。奇-偶-奇。。。一个点可能既可以在 两种情况下 都被访问 用vis[MAXN][2]全记录下来3.打印路径记录每个点在奇偶路径下的父亲 回溯输出//一开始暴力从始点枚举。。RE了多半递归炸了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int MAXN = 200100;vector&lt;int&gt; G[MAXN&lt;&lt;1];int n,m;int vis[MAXN][2];//1--到。。。可以为奇数路径int fa[MAXN][2];//0--到。。。可以为偶数路径void dfs(int s,int flag) //处理出s点的可走路径奇偶&#123; vis[s][flag]=1; for(auto v:G[s]) &#123; if(!vis[v][1-flag]) &#123; fa[v][1-flag]=s; dfs(v,1-flag); &#125; &#125;&#125;void print_ans(int u,int flag)&#123; if(u==0) &#123; return ; &#125; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;flag&lt;&lt;endl; //cout&lt;&lt;fa[u][flag]&lt;&lt;endl; print_ans(fa[u][flag],1-flag); cout&lt;&lt;u&lt;&lt;" ";&#125;void show()&#123; cout&lt;&lt;endl; cout&lt;&lt;fa[5][1]&lt;&lt;endl; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;2; j++) cout&lt;&lt;fa[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;int c[MAXN];bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof vis); for(int i=1; i&lt;=n; i++) &#123; int num; cin&gt;&gt;num; for(int j=0; j&lt;num; j++) &#123; int to; cin&gt;&gt;to; G[i].push_back(to); &#125; &#125; int s; cin&gt;&gt;s; memset(fa,0,sizeof fa); dfs(s,0); for(int i=1; i&lt;=n; i++) if(G[i].empty()&amp;&amp;vis[i][1]) &#123; cout&lt;&lt;"Win"&lt;&lt;endl; print_ans(i,1); return 0; &#125; memset(c,0,sizeof c); if(huan(s)) puts("Draw"); else puts("Lose"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>拆点</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
</search>
