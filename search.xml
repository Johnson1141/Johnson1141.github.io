<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2F2018%2F12%2F05%2FLCS%2F</url>
    <content type="text"><![CDATA[给出两个串 ，输出最长公共子序列学习地址：https://blog.csdn.net/zhijianshafeiyang/article/details/45034853 “用一个数组将第一个串内元素在第二个串内的位置保存下来，求这个数组的最长上升子序列长度”什么叫第一个串内元素在第二个串内的位置？比如 str1 = avbasx str2 = abcaszx 位置是反序 就是 4，1——2——4，1——5——7eg2： aaba abaa 4 3 1 —— 4 3 1—— 2 —— 4 3 1 两个问题 1.记录位置 2.位置的反序 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100000;//---------------int ans[MAX];vector&lt;int&gt; a;int LIS()&#123; int len=1; ans[0]=a[0]; for(int i=1;i&lt;a.size();i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++] = a[i]; else *lower_bound(ans,ans+len,a[i]) = a[i]; &#125; return len;&#125;//--int a1[MAX],a2[MAX];int LCSlen1,LCSlen2;int LCS()&#123; map&lt;int,int&gt; pos; a.clear(); for(int i=0;i&lt;LCSlen1;i++)&#123; pos[a1[i]] = i; &#125; for(int i=0;i&lt;LCSlen2;i++)&#123; if(pos.find(a2[i])!=pos.end()) a.pb(pos[a2[i]]); &#125; return LIS();&#125; 区域赛更新1234567891011121314int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[===20180717SHU暑期集训训练赛(6)===]]></title>
    <url>%2F2018%2F07%2F17%2F20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B-6%2F</url>
    <content type="text"><![CDATA[B D E K L是看过的题但没过 B蔡老师强啊 样例看了好久看不懂，磨到晚上蔡老师才指点迷津先解释样例1 2 有三组 就是3C2=3（1 2 ，3 1）和（3 1，1 2）为一组（1 2，1 2，3 1）和（1 2，3 1，1 2）为一组加起来五组 （这道题看似图论，跟图论没半毛钱关系）之前不小心看到题解了是hash，还是两次hash，怎么搞？想一想。想不出啊。让我猜猜看，边hash成一个值，多条边再hash成一个值？？不对啊 老哥额 还要一个公式 (n+1)C2 - nC2 = n就是说每加入一个新的值 ans都要加上 原有个数（注意不是n+1是n）相同值的hash值相加一样没问题，但不同的数的hash值相加会不会也一样？应该不一样把，人家都过了这道题了，hash不就是解决这个问题的嘛，不清楚，没学过。双hash函数 保证没有例外12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1&lt;&lt;12;//两个hash函数 所需seed 和 pLL seed1=13131313,seed2=23333333,mod1=1e9+7,mod2=1e9+9;LL p1[N],p2[N];map &lt;pair&lt;int,int&gt;,LL&gt; id;int a[N];map&lt;pair&lt;int,int&gt;,LL&gt; cnt[N];int main()&#123; p1[0]=p2[0]=1; for(int i=1; i&lt;N; i++) p1[i] = p1[i-1] * seed1 % mod1; for(int i=1; i&lt;N; i++) p2[i] = p2[i-1] * seed2 % mod2;//这两步的意义是处理什么？写hash函数 fastin int t; cin&gt;&gt;t; while(t--) &#123; id.clear(); int n; cin&gt;&gt;n; for(int i=0,x,y; i&lt;n; i++) &#123; //将边hash成一个id值 cin&gt;&gt;x&gt;&gt;y; if(x&gt;y) swap(x,y); if(id.find(&#123;x,y&#125;)==id.end()) id[&#123;x,y&#125;] = id.size(); a[i] = id[&#123;x,y&#125;] ; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) cnt[i].clear(); for(int i=0; i&lt;n; i++) &#123; LL sum1=0,sum2=0; for(int j=i; j&lt;n; j++) &#123; (sum1+= p1[a[j]]) %=mod1; (sum2+= p2[a[j]]) %=mod2; ans+=cnt[j-i][ &#123;sum1,sum2&#125;]; //厉害啊 想不到 cnt[j-i][ &#123;sum1,sum2&#125;]++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 半抄半做的题，到时候再重新做一下 D The main idea is that we only need to keep track of the number of active cells and the last strictly increasing sequence of powers from right to left, this is because if we have a cell with number X and the cell to the right has number Y where Y &gt; X , these two cells will never merge and therefore anything to the left of them won’t add anything to the score so we don’t need to keep track of them.This leads to a DP Bitmask solution where we store the bitmask of available powers of 2 (they are guaranteed to be strictly increasing from right to left because we ignore any powers that aren’t) and the number of active cells (free cells + number of bits in the mask).If the current mask is msk and a 4 is generated, the new mask will become msk + 4 and ((msk)^(msk + 4)) - 4 will be added to the score.When a 2 is generated, the new mask will become msk + 2 and ((msk)^(msk + 2)) - 2 will be added to the score.The added score explained above is the score added from all the merge operations that will happen after adding the new number, not only the first one. Merging them all at once will not affect the final answer.^ is the bitwise XOR operator. 毫无头绪，不好意思英文的题解，慢慢啃吧尽力了 下一道E。。。。下一道 K生成树 ，李老师说的对啊，我错了先找到环上的任意一条边，去掉它，这张图就成为一个树了那么不考虑去掉的那条边，就是一个lca问题。只是在这里没有那么简单，要考虑经过那条边的情况，无非多出两种情况总共三种情况 1.不经过u—v lcm //不经过去掉的边2.从u到v w+x–u+y–v3.从v到u w+x–v+y–u 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1e5+10;struct edge&#123; int to; LL w;&#125;;vector&lt;edge&gt; G[N];int father[N];int Find(int x)&#123; return x==father[x] ? x : father[x]=Find(father[x]);&#125;void Union(int x,int y)&#123; int rx=Find(x),ry=Find(y); if(rx==ry) return ; father[rx]=ry;&#125;//lca 一dfs处理深度 和faint dep[N],fa[N][30];LL d[N];//i到1的距离int n,q;void dfs(int u,int pre,LL dis)&#123; fa[u][0]=pre; d[u] = dis; for(auto tmp:G[u]) &#123; int v=tmp.to; LL distance=tmp.w; if(v!=pre) &#123; dep[v]=dep[u]+1; dfs(v,u,d[u]+distance); &#125; &#125;&#125;void bz()&#123; for(int j=1; j&lt;=29; j++) for(int i=1; i&lt;=n; i++) fa[i][j] = fa[fa[i][j-1]][j-1];&#125;void LCAinit()&#123; clr(dep,0); dep[1]=1; clr(d,INF); dfs(1,0,0); bz();&#125;int LCA(int u,int v)&#123; if(dep[u]&gt;dep[v]) &#123; swap(u,v); &#125; int cha = dep[v] - dep[u]; int len = log2(n); for(int x=0; x&lt;=len; x++) if((1&lt;&lt;x)&amp;cha) v=fa[v][x]; if(u==v) return u; for(int x=len; x&gt;=0; x--) &#123; if(fa[v][x]!=fa[u][x]) &#123; u=fa[u][x]; v=fa[v][x]; &#125; &#125; return fa[u][0];&#125;LL dis(int x,int y)&#123; int c=LCA(x,y); return d[x]+d[y]-2*d[c];&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; for(int i=0;i&lt;=n;i++) G[i].clear(); scanf("%d%d",&amp;n,&amp;q); for(int i=0; i&lt;=n; i++) father[i]=i; int in,out,w; for(int i=0,x,y; i&lt;n; i++) &#123; LL val; scanf("%d%d%lld",&amp;x,&amp;y,&amp;val); if(Find(x)==Find(y)) &#123; in=x,out=y,w=val; &#125; else &#123; Union(x,y); G[x].push_back(edge&#123;y,val&#125;); G[y].push_back(edge&#123;x,val&#125;); &#125; &#125; LCAinit(); for(int i=0,x,y; i&lt;q; i++) &#123; scanf("%d%d",&amp;x,&amp;y); LL ans=dis(x,y); ans=min(ans,dis(x,in)+dis(out,y)+w); ans=min(ans,dis(x,out)+dis(in,y)+w); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716SHU暑期集训组队赛(5)===]]></title>
    <url>%2F2018%2F07%2F16%2F20180717SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E7%BB%84%E9%98%9F%E8%B5%9B-5%2F</url>
    <content type="text"><![CDATA[又tm垫底了两道图论+二分答案没过模板 迪杰斯特拉最短路 + 二分答案 二分图匹配+二分答案特点：最大化其中最小值（最小化其中最大值）多源bfs？最小化最远距离（对于状态而言） https://vjudge.net/contest/237325#problem/D（）先打两个模板压压惊，去洛谷啊 E dij+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const LL INF = LL(1)&lt;&lt;50;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=500010;struct node&#123; int x; LL val; bool operator &lt; (const node&amp;a)const &#123; return val&gt;a.val; &#125;&#125;;vector&lt;node&gt; G[N];int vis[N];LL dis[N];int n,m,x;int mz;bool Dij(LL lim)&#123; clr(vis,0); for(int i=0;i&lt;=n;i++) dis[i]=INF; priority_queue&lt;node&gt; q; dis[1]=0; q.push(node&#123;1,0&#125;); node tmp; while(!q.empty()) &#123; tmp=q.top(); q.pop(); int u=tmp.x; if(vis[u]) continue; vis[u]=1; for(auto nd:G[u]) &#123; int v=nd.x; LL cost=nd.val; if(cost &gt; lim) continue; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; q.push(node&#123;v,dis[v]&#125;); &#125; &#125; &#125; if(dis[n]&lt;=mz) return true; return false;&#125;void showg()&#123; for(int i=1;i&lt;=n;i++)&#123; for(auto v:G[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.val; cout&lt;&lt;endl; &#125;&#125;int main()&#123; fastin cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=0,u,v;i&lt;m;i++)&#123; LL dis; cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis; G[u].push_back (node&#123;v,dis&#125;); G[v].push_back (node&#123;u,dis&#125;); &#125; Dij(1e7); mz=dis[n]*(1.0+x/100.0); LL l=0,r=INF; while(r-l&gt;1)&#123; LL mid=l+(r-l)/2; if( Dij(mid) ) r=mid; else l=mid; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; J 二分图匹配+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=5010;const int M=50010;vector&lt;int&gt; G[N];int link[N],used[N];int n,m;int uN;bool dfs(int u)&#123; for(auto v:G[u]) &#123; if(!used[v]) &#123; used[v]=1; if(link[v]==-1||dfs(link[v])) &#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res=0; memset(link,-1,sizeof link); for(int u=1; u&lt;=uN; u++) &#123; clr(used,0); if(dfs(u)) res++; &#125; return res;&#125;int dis[110][110];bool judge(int lim)&#123; for(int i=0; i&lt;=n; i++) G[i].clear(); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(dis[i][j]&lt;=lim) &#123; G[i].pb(j+n); G[j+n].pb(i); &#125; return hungary()==n;&#125;int xx[240];int yy[240];int main()&#123; fastin cin&gt;&gt;n; uN=n; for(int i=1; i&lt;=2*n; i++) &#123; cin&gt;&gt;xx[i]&gt;&gt;yy[i]; &#125; for(int i=1; i&lt;=n; i++) for(int j=n+1; j&lt;=2*n; j++) dis[i][j-n] = abs(xx[i]-xx[j])+abs(yy[i]-yy[j]); int l=0,r=1e8; while(r-l&gt;1) &#123; int mid=l+(r-l)/2; if(judge(mid)) r=mid; else l=mid; //cout&lt;&lt;mid&lt;&lt;endl; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; 二分答案题感觉都是00000000000001111111111111111111（求第一个1）或11111111111111110000000000000000（求第一个0）而不能解决 类似于0111111000011111000011111000000（求第一个0）记住就好了 G大意：有多个点，对于每个点，给定它的坐标和曼哈顿半径，求有几个交点0个就impossible 1就输出那个交点 2就uncertain最多 4e61+1e6 1000好气啊 当时都想出来了 复杂度推错了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;struct node&#123; int x,y; bool operator&lt; (const node&amp;a)const &#123; return x&lt;a.x; &#125;&#125;;vector&lt;node&gt; st[2];int main()&#123; fastin int n;cin&gt;&gt;n; int x,y,dis;cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(int i=-dis;i&lt;=dis;i++)&#123; st[0].push_back(node&#123;x+i,y+dis-abs(i)&#125;); if(i!=-dis &amp;&amp; i!= dis) st[0].push_back(node&#123;x+i,y-dis+abs(i)&#125;); &#125; int flag=1; for(int i=1;i&lt;n;i++)&#123; st[flag].clear(); cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(auto v:st[1^flag]) if(abs(x-v.x)+abs(y-v.y)==dis) st[flag].push_back(node&#123;v.x,v.y&#125;); flag^=1; &#125; flag^=1; /* for(int i=0;i&lt;2;i++)&#123; for(auto v:st[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.y&lt;&lt;endl; cout&lt;&lt;endl; &#125; */ if(st[flag].size()==1) cout&lt;&lt;st[flag][0].x&lt;&lt;" "&lt;&lt;st[flag][0].y&lt;&lt;endl; else if(st[flag].size()==0) puts("impossible"); else puts("uncertain"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑期集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716 SHU暑期集训个人赛(3)===]]></title>
    <url>%2F2018%2F07%2F16%2F%3D%3D%3D20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B(3)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[垫底之旅2016-2017 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2016) 看的题 但没做出来 感觉都在能力范围之内 就是没想到 A倒跑并查集也蛮难写的 也要把一个点hash成一个值 就是二维变一维嘛这 怎么想的到 Btire树上的bfstire树都不知道是是什么 你让我怎么做 C对一副乱序的扑克牌求排有序的最小交换相邻元素的操作个数首先数据规模很小 （最多52张牌嘛）先想想最暴力的做法咯 就对于给定的一副牌排序的结果无非是 4!（花色全排列）*2^4（顺序和倒序）种结果 384例如样例12h Th 8c Qh所有的可能性 1.2h Th Qh 8c 2.8c 2h Th Qh还有倒序的，不写了那验证每一种初态到给定态的检查的方法复杂度要多少啊？不知道啊 卡住了啊 看题解。。。怎么就LCS了拉 我怎么不知道什么意思啊？那就考虑一个更简单的模型一串乱序的数字序列 需要相邻元素交换几次才能变为不下降序列？额 不需要相邻元素 随便交换 又读错题了。。。。Sorting is done by moving one card at a time fromits current position to a new position in the hand, atthe start, end, or in between two adjacent cards. Whatis the smallest number of moves required to sort agiven hand of cards?枚举4！种排列组合 和2^4 正序 倒序 暴力求解求出最大的LCS就可以拉有个小tips：A是王牌 是最大的。。。。wa了好几发 读题读题看错题太蠢了 F推公式 排列组合题 ，没什么难度 但我推不出 H见过一道差不多的，没去写，亏了。找了半个小时没找到 算了。额 我错了 看了那么久 还是看不懂抄一遍代码 找感觉吧额 又看了一遍题目。知道了，感觉有意思。大意是：给n个矩形，让他们一个一个往上叠，约束条件是 宽严格递减（矩形可以旋转，所以长宽可以交换），求最大高度。（n个矩形都要用到）1，建图。当时第一步都没想到，鬼知道要长宽相连建图啊，但其实应该知道，这已经不是第一次遇到了。（第二次）建图前想一想，该怎么建图，如果单纯相连，那图的意义，边的意义，点的意义是什么？这里主要是边的意义,认为规定 a-&gt;b的有向边是这个矩形啊 a为宽，b为高放置。（鬼才想的到，我想不到。）利用约束条件有对这个图产生了新的限制：一个点最多一个出度（这个点只能做一次宽）这个图可能有许多连通分支，就挑一个来看，这个连通分支有什么特点2，已知：输入保证n个矩形能叠起来那上界，n个点是不是最多n条边？ 额，不知道。证明一下咯，如果有n+1条边，至少一个点的出度&gt;=2.有n条边，那连通分支中有一个环，再加一条边，又多一个环，就是说，n+1条边的无向图中有两个环一个环已经自给自足了，没法有出度的边了，那只能别人进去，有两个别人需要进去的点（环缩点），那势必有一个点需要出度两次。===\1.png) 所以n个点的连通分支最多只有n条边。 考虑下界，n个点的连通分支最少有n-1条边（一棵树，真的不能再少了，再少就两个连通分支了。。。）所以只有两种情况，n个点n条边，每个点都出度一次n个点n-1条边，有一个点无需出（哪个点不用做宽啊，哪肯定是值最大的那个啊，给我滚去做高啊） 那怎么写啊。。。。。额 抄一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int N = 5e5;vector&lt;int&gt;G[N];int val[N];int vis[N];int sz=0;int maxv,deg;LL ans=0;map&lt;int,int&gt; id;void dfs(int u)&#123; vis[u]=1; deg+=G[u].size()-2; //妙啊 一条边贡献两个度数，要是树的话，只有2n-2个总度数 ans+=LL(val[u])*(G[u].size()-1); maxv=max(maxv,val[u]); //维护最大点 for(auto v:G[u])&#123; if(!vis[v]) dfs(v); &#125;&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=0,x,y;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(id.find(x)==id.end()) id[x]=++sz,val[sz]=x; //缩点 if(id.find(y)==id.end()) id[y]=++sz,val[sz]=y; G[id[x]].pb(id[y]); G[id[y]].pb(id[x]); &#125; clr(vis,0); ans=0; for(int i=1;i&lt;=sz;i++)&#123; if(!vis[i]) &#123; maxv=0,deg=0; dfs(i); if(deg!=0) ans+=maxv; //是个树加上最大的那个点 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>倒跑</tag>
        <tag>字典树</tag>
        <tag>排列组合</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180619 SHU暑期集训个人赛(1)]]></title>
    <url>%2F2018%2F06%2F19%2F%3D%3D%3D20180619SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E4%B8%AA%E4%BA%BA%E8%B5%9B(1)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[A - Subarrays BeautyGym - 101532A 找规律 注意位运算 多半是对位的找规律 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[100010];LL b[100010];int n;LL func(LL x)&#123; return x*(x+1)/2;&#125;LL coun()&#123; LL num=0; LL ans=0; for(int i=0;i&lt;n;i++)&#123; if(num&gt;0&amp;&amp;b[i]==0) &#123; ans+=func(num);num=0; &#125; if(b[i]==1) num++; &#125; ans+=func(num); return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);LL _max=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]);_max=max(_max,a[i]); &#125; int wei=log2(_max); wei+=2; LL ans=0; LL basic=1; for(int i=0;i&lt;wei;i++,basic&lt;&lt;=1)&#123; for(int j=0;j&lt;n;j++)&#123; b[j]= a[j]&amp;1; a[j]&gt;&gt;=1; &#125; ans+=basic*coun(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;/*237 11 9411 9 6 11*/ B - Array Reconstructing Gym - 101532B 简单题 我都记不清是什么题了 多半是尝试 打印答案 //想起华师的第二道题 妈的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[1010];int n;void print_ans(int x,LL val,LL m)&#123; for(int i=x+1;i&lt;n;i++)&#123; a[i]=(a[i-1]+1)%m; &#125; for(int i=x-1;i&gt;=0;i--)&#123; a[i]=(a[i+1]-1+m)%m; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; LL m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]!=-1) &#123;print_ans(i,a[i],m);break;&#125; &#125; return 0;&#125;/*45 101 2 3 4 54 107 -1 9 -16 75 -1 -1 1 2 36 105 -1 7 -1 9 0*/ C - Large Summation Gym - 101532C二分 没什么特殊的 没接触过罢了lower_bound() &gt;=upper_bound() &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;struct node&#123; int no; int val; int ans;&#125;;int n;node a[200100];bool cmp1(node a,node b)&#123; return a.val&lt;b.val;&#125;bool cmp2(node a,node b)&#123; return a.no&lt;b.no;&#125;int findkey(int val,int pos)&#123; int l=0,r=n-1; int mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(a[mid].val&gt;val) r=mid-1; else l=mid+1; &#125; if(r==pos) r--; if(r&lt;0) return a[(pos+1)%n].val; return a[r].val;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123;cin&gt;&gt;a[i].val;a[i].no=i;&#125; sort(a,a+n,cmp1); for(int i=0;i&lt;n;i++)&#123; int ans1; if(i==n-1) ans1=(a[n-2].val+a[n-1].val)%mod; else ans1=(a[n-1].val+a[i].val)%mod; int tmp=findkey(mod-a[i].val-1,i); int ans2=(a[i].val+tmp)%mod; a[i].ans=max(ans1,ans2); &#125; sort(a,a+n,cmp2); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i].ans&lt;&lt;" "; cout&lt;&lt;a[n-1].ans&lt;&lt;endl; &#125; return 0;&#125;/*331 2 321000000000 10000000003500000007 500000002 500000003*/ D - Counting Test Gym - 101532D 预处理+查询注意l-r可以处理为 (1~r) - (1~l-1) 简单好多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[10010][26];char tmp;LL func(LL s,LL e)&#123; if(s==0) return a[e][tmp-'a']; return a[e][tmp-'a']-a[s-1][tmp-'a'];&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); memset(a,0,sizeof a); string s;cin&gt;&gt;s; a[0][s[0]-'a']++; for(int i=1;i&lt;n;i++)&#123; int num=s[i]-'a'; a[i][num]++; for(int j=0;j&lt;26;j++) a[i][j]+=a[i-1][j]; &#125; for(int i=0;i&lt;m;i++)&#123; LL ans=0; LL l,r;scanf("%lld %lld %c",&amp;l,&amp;r,&amp;tmp); l-=1;r-=1; if(r-l&lt;n)&#123; r%=n,l%=n; if(r&gt;=l) ans+=func(l,r); else&#123; ans+=func(l,n-1); ans+=func(0,r); &#125; &#125; else&#123; LL len1=r%n,len2=n-l%n; ans+=func(l%n,n-1); ans+=func(0,r%n); ans+=(r-l-len1-len2) / n * a[n-1][tmp-'a']; &#125; printf("%lld\n",ans); &#125; &#125;&#125;/*18 5abcabdca1 1 c1 15 b4 9 a5 25 d2 7 c*/ E - Game of Dice Gym - 101532E折半查找 第一次做 还可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const double eps = 1e-6;LL a[500][7];map&lt;LL,int&gt; c;int n;LL m;LL res=0;long long quickmod(long long a,long long b,long long m)&#123; long long ans = 1; while(b)&#123; if(b&amp;1)&#123; ans = (ans*a)%m;b--; &#125; b/=2; a = a*a%m; &#125; return ans;&#125;void dfs1(int cur,int e,LL ans)&#123; if(cur==e)&#123; ++c[ans]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs1(cur+1,e,(ans*a[cur][i])%mod); &#125;&#125;void dfs2(int cur,int e,LL ans)&#123; if(cur==e)&#123; res+=c[(m*quickmod(ans,mod-2,mod))%mod]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs2(cur+1,e,(ans*a[cur][i])%mod); //SDUSHADJKASDNJKASDHJK &#125;&#125;void init()&#123; res=0; c.clear();&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d %lld",&amp;n,&amp;m); init(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;6;j++) scanf("%lld",&amp;a[i][j]); int mid=n/2; dfs1(0,mid,LL(1)); dfs2(mid,n,LL(1)); cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; F - Strings and Queries Gym - 101532F 1.hash2.暴力枚举回文子串数量3.st处理区间问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int func(char s[])&#123; LL ans=0; int n=strlen(s); for(int i=0; i&lt;n; i++) &#123; for(int len=1; len&lt;n; len++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len]) ans++; else break; &#125; &#125; for(int i=0; i&lt;n-1; i++) if(s[i+1]==s[i]) &#123; ans++; for(int len=1; len&lt;n; i++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len+1]) ans++; else break; &#125; &#125; return ans;&#125;int c[40][40];int func1(string s)&#123; int len=s.size(); int sum=0; memset(c,0,sizeof c); for(int i=len-1; i&gt;=0; i--) &#123; c[i][i]=true; sum++; for(int j=i+1; j&lt;len; j++) &#123; if(s[i]==s[j]) &#123; if(i+1==j||c[i+1][j-1]) &#123; c[i][j]=true; sum++; &#125; &#125; else c[i][j]=false; &#125; &#125; return sum;&#125;LL Hash(string s)&#123; LL ans=0; int len=s.size(); for(int i=0; i&lt;len; i++) &#123; ans=ans*31+s[i]-'a'+1; &#125; return ans;&#125;struct node&#123; int no; int val; node(int n=0,int v=0) &#123; no=n; val=v; &#125; bool operator &lt; (const node&amp; a) const &#123; if(val==a.val) return no&gt;a.no; return val&lt;a.val; &#125;&#125;;char s[40];int n;node dp[10100][40];void st()&#123; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;node RMQ(int l,int r)&#123; int k=log2(r-l+1); return max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; map&lt;LL,int&gt; mp; int q; scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s); int num=func1(s); LL hs=Hash(s); mp[hs]=i; dp[i][0]=node(i,num); &#125; st(); for(int i=1; i&lt;=q; i++) &#123; char tmp1[40],tmp2[40]; scanf("%s",tmp1); scanf("%s",tmp2); LL hs1=Hash(tmp1),hs2=Hash(tmp2); int n1=mp[hs1],n2=mp[hs2]; if(n1&gt;n2) swap(n1,n2); printf("%d\n",RMQ(n1,n2).no); &#125; &#125; return 0;&#125;int main1()&#123; cout&lt;&lt;Hash("aaaa")&lt;&lt;endl; cout&lt;&lt;Hash("aaaaa")&lt;&lt;endl;&#125;/*35 5aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbcccaaaaccccaaaaaaaaaaaaaaaaccccccacccccc aaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa cccaaaaccccaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaacccccc aaaaaaaaaaaaa*/ G - Magical Indices Gym - 101532G 前缀 后缀 签到题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;int a[1000100];int maxtou[1000100];int minwei[1000100];int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i==0) maxtou[0]=a[0]; else maxtou[i]=max(maxtou[i-1],a[i]); &#125; minwei[n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--)&#123; minwei[i]=min(minwei[i+1],a[i]); &#125; int ans=0; for(int i=1;i&lt;n-1;i++)&#123; if(a[i]&lt;=minwei[i+1]&amp;&amp;a[i]&gt;=maxtou[i-1]) ans++; //cout&lt;&lt;a[i].index&lt;&lt;" "; &#125; printf("%d\n",ans); &#125; return 0;&#125;/*4101 2 1 1 1 1 1 1 1 153 3 4 5 3*/``` ## H - Corrupted Images Gym - 101532H 签到题注意角上的 唯一的坑点了吧```c++#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;char a[60][60];int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; int num=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='1') num++; &#125; if( num&lt;(2*n+2*m-4) ) &#123;cout&lt;&lt;"-1"&lt;&lt;endl;continue;&#125; int ans=0; for(int j=0;j&lt;m;j++)&#123; if(a[0][j]=='0') ans++; if(a[n-1][j]=='0') ans++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i][0]=='0') ans++; if(a[i][m-1]=='0') ans++; &#125; if(a[0][0]=='0') ans--; if(a[n-1][0]=='0') ans--; if(a[0][m-1]=='0') ans--; if(a[n-1][m-1]=='0') ans--; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; I - The Crazy Jumper Gym - 101532I dp注意下一个元素是要特殊处理 不然会超时一步步覆盖 从头想想从尾部会怎么样？12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int a[200110];int pos[200110];int dp[200110];int n;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); dp[0]=-1; memset(pos,0,sizeof pos); for(int i=1;i&lt;=n;i++)&#123; int val; scanf("%d",&amp;val); dp[i]=dp[i-1]+1; if(pos[val]!=0) dp[i]= min ( dp[i] , dp[ pos[val] ]+1); pos[val] = i ; &#125; printf("%d\n",dp[n]); &#125;&#125; J - The Hell Boy Gym - 101532J 公式 或者 递推数学问题12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9+7;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); LL ans=1,tmp; while(n--) &#123;scanf("%lld",&amp;tmp); ans=(ans*(tmp+1))%mod;&#125; printf("%lld\n",(ans+mod-1)%mod); &#125; return 0;&#125; ##K - Palindromes Building Gym - 101532K 组合数学123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int P[12];void pre()&#123; P[0]=1; for(int i=1;i&lt;=11;i++) P[i]=i*P[i-1];&#125;int main()&#123; pre(); int t;cin&gt;&gt;t; while(t--) &#123; int n;int l[26]; memset(l,0,sizeof l); cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char tmp;cin&gt;&gt;tmp; l[tmp-'a']++; &#125; int num=0; for(int i=0;i&lt;26;i++) if(l[i]&amp;1) num++; if(num&gt;=2)&#123; cout&lt;&lt;0&lt;&lt;endl;continue;&#125; int len=0; for(int i=0;i&lt;26;i++) &#123;l[i]/=2;len+=l[i];&#125; int ans=P[len]; for(int i=0;i&lt;26;i++) &#123;ans/=P[l[i]];&#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L - List Of Integers CodeForces - 920G 二分答案 之后容斥验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long long ll;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;void show()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;vector&lt;LL&gt; vec;LL cnum(LL r) //求1-r中与 k（不）互质 的元素的个数&#123; LL ans=0; int wei=vec.size(); for(LL i=1; i&lt;(1LL&lt;&lt;wei); i++) &#123; int bits=0,multi=1; for(LL j=0; j&lt;wei; j++) &#123; if(i&amp;(1LL&lt;&lt;j)) &#123; bits++; multi*=vec[j]; &#125; &#125; LL cur=r/multi; if(bits&amp;1) ans+=cur; else ans-=cur; &#125; //return ans; //返回与其不互质的元素个数 return r-ans;//返回与其互质的元素个数&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; LL l,no, p; scanf("%lld%lld%lld",&amp;l,&amp;p,&amp;no); vec.clear(); LL ans=0; for(LL i=2; i*i&lt;=p; i++) &#123; if(p%i==0) vec.push_back(i); while(p%i==0) p/=i; &#125; if(p&gt;1) vec.push_back(p); LL r=1e12; LL tmp=no+cnum(l); while(l&lt;=r) &#123; LL mid=l+(r-l)/2; if(cnum(mid)&gt;=tmp) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125; N - Sleepy GameCodeForces - 936B 三种简单图论知识的集合题 1.有向图 dfs判环 vis[] 标记 三种标记 0代表未访问 1代表正在访问这个分支 2代表访问完成某一分支 什么时候会形成环？ 这个点的分支在访问的时候又回到了自己这个点 蔡老师强啊 一般我会写 1234567891011121314bool huan(int u)&#123; bool flag=false; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1) return true; else if(c[v]==0)&#123; if(huan(v)) flag=true; &#125; &#125; c[u]=2; return flag;&#125; 又丑又长12345678910bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125; 对判环理解很深刻（&amp;&amp;与||优先级 不要怕 大胆写啊） 2.拆点一张图拆成两张图 偶数路径 奇数路径偶-奇-偶-。。。。。奇-偶-奇。。。一个点可能既可以在 两种情况下 都被访问 用vis[MAXN][2]全记录下来3.打印路径记录每个点在奇偶路径下的父亲 回溯输出//一开始暴力从始点枚举。。RE了多半递归炸了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int MAXN = 200100;vector&lt;int&gt; G[MAXN&lt;&lt;1];int n,m;int vis[MAXN][2];//1--到。。。可以为奇数路径int fa[MAXN][2];//0--到。。。可以为偶数路径void dfs(int s,int flag) //处理出s点的可走路径奇偶&#123; vis[s][flag]=1; for(auto v:G[s]) &#123; if(!vis[v][1-flag]) &#123; fa[v][1-flag]=s; dfs(v,1-flag); &#125; &#125;&#125;void print_ans(int u,int flag)&#123; if(u==0) &#123; return ; &#125; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;flag&lt;&lt;endl; //cout&lt;&lt;fa[u][flag]&lt;&lt;endl; print_ans(fa[u][flag],1-flag); cout&lt;&lt;u&lt;&lt;" ";&#125;void show()&#123; cout&lt;&lt;endl; cout&lt;&lt;fa[5][1]&lt;&lt;endl; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;2; j++) cout&lt;&lt;fa[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;int c[MAXN];bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof vis); for(int i=1; i&lt;=n; i++) &#123; int num; cin&gt;&gt;num; for(int j=0; j&lt;num; j++) &#123; int to; cin&gt;&gt;to; G[i].push_back(to); &#125; &#125; int s; cin&gt;&gt;s; memset(fa,0,sizeof fa); dfs(s,0); for(int i=1; i&lt;=n; i++) if(G[i].empty()&amp;&amp;vis[i][1]) &#123; cout&lt;&lt;"Win"&lt;&lt;endl; print_ans(i,1); return 0; &#125; memset(c,0,sizeof c); if(huan(s)) puts("Draw"); else puts("Lose"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>拆点</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
</search>
