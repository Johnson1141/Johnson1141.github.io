<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssh私钥和公钥]]></title>
    <url>%2Funcategorized%2Fssh%E7%A7%81%E9%92%A5%E5%92%8C%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[pre要连接到一个服务器 两个级别的安全验证 基于口令（密码） 基于密钥 之前一直使用密码登陆，因为xshel会帮你记住一切参数，而且ios，安卓也可以简单的登陆，但切换到ubuntu就没有那么方便，需要配置ssh。 但说实话，基于密钥的登陆方法才比较安全，比主流的。 knowledge公钥和私钥 公钥: 公开的密钥，所有人都可以知道 私钥: 私有的密钥，只有自己知道 关系：1. 公钥和私钥是成对的，它们互相解密。 2. 公钥加密，私钥解密。 3. 私钥数字签名，公钥验证。 流程：消息-–&gt;[公钥]-–&gt;加密后的信息-–&gt;[私钥]-–&gt;消息 结论所以简单来说你需要让服务器知道你的公钥才能让它发出用你公钥加密的信息，看你能不能用自己的私钥解密，来判断你能不能登陆。 practisepre综上所述，我们要做的很简单。 生成客户端的公钥和私钥。 把客户的公钥上传你的服务器。 代码生成密钥ssh-keygen -t rsa -C &quot;你的邮箱&quot; 之后全按enter 发送秘钥 上一条命令运行过程中会告诉你秘钥的位置 不出意外的话，密钥的位置在 ~/.ssh/id_rsa (私钥) ~/.ssh/id_rsa.pub (公钥) 我们需要发送公钥到远程主机 ssh-copy-id -i ~/.ssh/id_rsa.pub 用户名@服务器地址（ip或者域名） 注:若是你自己改过默认端口22，则加参数-p xxxx 简来来说，若登陆命令是ssh xx,则上传命令是 ssh-copy-id -i ~/.ssh/id_rsa.pub xx 。]]></content>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 简单上手]]></title>
    <url>%2Funcategorized%2Fubuntu%2018.04%20%E7%AE%80%E5%8D%95%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[开机自启动 直接搜索 “启动” 选择启动应用程序首选项 如果找不到 就去ubuntu的应用商店，搜索启动，挑个顺眼的应用。我好像默认安装了 安装后打开 然后添加脚本就可以了。 对于18.04而言最好不要照网上修改rc.loacl 搞不好会崩的，差点重装系统。 修改wine应用分辨率调整“qq轻聊版”字体大小 WINEPREFIX=~/.deepinwine/Deepin-QQLight deepin-wine winecfg 显示那里改屏幕分辨率就可以 理论上来说 只要是在~/.deepinwine文件夹下的所有win应用都可以这样改大小把 Deepin-QQLight替换成你想改的软件 触控板 多点手势安装Fusuma https://github.com/iberianpig/fusuma#installation 安照github上指示一步步做 前置不知道装没装过 ruby 就先装一下 sudo apt-get install ruby 整合步骤$ sudo gpasswd -a $USER input ！！然后reboot或者logout 这样才能把当前用户使用触控板这个指令生效（我是重启成功的） $ sudo apt-get install libinput-tools $ sudo gem install fusuma $ sudo apt-get install xdotool $ gsettings set org.gnome.desktop.peripherals.touchpad send-events enabled 启动$ fusuma 更新$ sudo gem update fusuma 个性化配置文件$ mkdir -p ~/.config/fusuma # 创建目录 $ sudo vim ~/.config/fusuma/config.yml # 编辑配置文件 //Tab 需要重启才能看见效果 个人配置12345678910111213141516171819202122232425262728293031323334353637383940swipe: 3: left: command: &apos;xdotool key alt+Tab&apos; right: command: &apos;xdotool key alt+shift+Tab&apos; up: command: &apos;xdotool key ctrl+t&apos; threshold: 1.5 down: command: &apos;xdotool key ctrl+w&apos; threshold: 1.5 4: left: # command: &apos;xdotool key super+Right&apos; command: &apos;xdotool key super+Left&apos; right: # command: &apos;xdotool key super+Left&apos; command: &apos;xdotool key super+Right&apos; up: command: &apos;xdotool key super+s&apos; down: command: &apos;xdotool key super+d&apos;pinch: 2: in: command: &apos;xdotool key ctrl+plus&apos; threshold: 0.1 out: command: &apos;xdotool key ctrl+minus&apos; threshold: 0.1threshold: swipe: 1 pinch: 1interval: swipe: 1 pinch: 1]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps配置-vpn]]></title>
    <url>%2Funcategorized%2Fvps_vpn%2F</url>
    <content type="text"><![CDATA[选择一个vps首先给个忠告，要货比三家，并且不要心急，vps就在那里，晚点买并不会怎么样 一、 vultr比较不错的vps，也是我选择的vps，主要靠韬哥推荐（和好看的界面）本来只需2.5美元的月租，现在要3.5美元了，2.5美元套餐只提供ipv6，运营商怎么可能会支持。没办法只能选3.5美元的。 二、搬瓦工（BandwagonHost）有一个方案性价比比较高，$19.9/year,平均￥12/month,如果单纯只是搭个vpn的话，性价比非常之高。 但目前这个套餐售罄了，要买只能等了，等不及就直接vultr$3.5上车吧。 个人采用的是vultr，教程比较多，可以向韬哥请教，还可以搭个个人网盘+下载器去消耗用不完的流量。 正式搭建注册这个就不详细说了，简单的。 开设服务器1.选择节点 随便选吧，一般来说选Los Angeles（洛杉矶），Seattle（西雅图）等美国站点，不过最终还是按实际结果来。 2.选择服务器类型我选择的是64位centos7，之后的架设都是在此基础上的。 3.选择套餐 不说了，选 $3.5 4.其他操作其他现在都不用关心，之后要是搭建其他东西，你就会明白的。 要填的就最后一行 填你的主机名，随便填，就是用于辨识你的vps。 远程主机连接不了好，现在你刚刚创建了一台vps，但还是台只有系统的裸机。你尝试用xshell等远程登录软件登远程登录，但登不上这个时候，多半是ip被封了。怎么看有没有被封呢？ 给两个扫描端口的网站，国内端口扫描国外端口扫描 先扫国外端口ip:填你的ip 端口:22（默认就是22） 一般都是开的，要是在这步就炸了，就重新删vps再重新开始吧,也可以改防火墙，但有点麻烦，还是删vps吧。 再扫国内端口 这里可能22端口会关上，如果关闭了，那就删vps再来吧，不然这个vps就是可用的。 最直接的解决方法就是删机重来，一个节点不行换另一个。 远程登录如果一切顺利，那么你就拥有了一台可以远程登录的主机。 windows用xshell，putty等工具登录。 linux直接用ssh指令登录 ssh root@yourip 密码在server details 里 点进去就能找到 如果觉得用账号密码登录太烦，可以用秘钥登录。详见 搭建vpn（服务端）这里都使用了一键脚本 感谢大佬 （参考韬哥的博客） 安装shadowsockswget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 注意在过程中记下密码,加密方式,端口，最终有参数，最好截个图。 卸载: ./shadowsocks.sh uninstall 启动： /etc/init.d/shadowsocks start 停止： /etc/init.d/shadowsocks stop 重启： /etc/init.d/shadowsocks restart 状态： /etc/init.d/shadowsocks status 锐速加速一键安装 wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh //安装 我折腾了好久，锐速的内核，最后莫名其妙就好了，待我好好琢磨琢磨,之后更新 好，目前为止服务端的配置已经结束了 使用vpn（客户端）目前用的系统是ubuntu18.04lts，之前用的win都分享一下吧。 windows直接下windows的shadowsocks的客户端，把你的参数都填入。 ubuntu配置有点麻烦 shadowsocks安装apt-get install python-pip pip install shadowsocks shadowsocks配置也可以装qt的图形界面，但相信我，会很不爽的。 sudo vi /etc/shadowsocks.json 然后写入 { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;server_port&quot;:my_server_port, &quot;password&quot;:&quot;my_password&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot; } 启动 sslocal -c /etc/shadowsocks.json 如果需要开机启动，详情 添加 sslocal -c /etc/shadowsocks.json 浏览器chrome代理设置设置到这里，但还是不能科学上网，你需要用插件代理chrome。 安装SwitchyOmega插件 Github下载SwitchyOmega： SwitchyOmega 下载crx文件 chrome 安装 插件，如果不让装，就用开发者模式，打开crx解压后的文件夹。 下载官方的配置文件： 配置文件 然后导入，如果你的本地地址是1080，没有改动的话，是可以直接用的。 然后直接重启，观察效果。 如果没有成功，就检查以上每个步骤，多重启，多sslocal。 尾声到现在，不出意外就可以科学上网了，但vps的性能还是略有剩余，500G的流量感觉挺少，但正常使用根本用不完，还有20G的ssd，我是搭建了一个私人网盘nextcloud，再搭配上aris2可以简单榨干存储容量和流量，博客之后放出。 end]]></content>
      <tags>
        <tag>vps</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六级随感]]></title>
    <url>%2Funcategorized%2F%E5%85%AD%E7%BA%A7%E9%9A%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! U2FsdGVkX1+vkbU3vpfyjc18+hB7FTCWOFM+H2M8c7pl0+CowFuKlM4UEqFEtn2Dlxwrg7NRUTbHryA0oBw/dlcCoHJIyFmCWsBI5vbut9Q6v4TGhygtbrynLO967K2iEEd2PZFEUUte9p1TP6VrTz+v9DDzBJ70bW78zejfCYxFNPWBF+nX+vSTavg3k7hVyXcChrADWDGn+nOhCP+HJxWZdzm8ecnLTpqFoUGRmBX1lxan2Pt9fVFqJwCHqZyxNkaG+EAWy8Z2ifOXsAlvpASxTZLTweOsmSZ4DKGtpOgvcxIoS/rbowY7NPcnALzyd00UjixXcoUcslovKr38llYaKvR0AjymqOVei9VRpzi7g00Dtv8U0rWCYiAJRK17en5IIicqvkQx6gUg547eb6NaZlALao4Fl2bAe7WuZlOl9usLu3TJNDA/v+Jp81SXU2nVgzoPydZfxhbcWDWtlY1zH69pQaF0I9T28LW+to41m8jLmOTOUHWwU+m9VzWvE8eHC2+upnW+VwvWJqArEcFSiKBjOwzCk6n8idcdoc2Dp4t6NalHwBNcwm86YdzCtZAqe7gFr/w3ocyrS2C+8QvWGavcsGB0V2+kBDTYDnwrVcOPIwquuWI4Y4Wy+Vc0NvIXudQNvQD1G4RlZiDkwJp/6BclMwzRUfVVRk7qk9Wr0UfRk1rY5CUXGOvtvLKjWWWl4JqYDhoknDd1s+DWZMos01+u/lW6d4RpYO42rGHUbOKNBtHnwYHgEeVeZqe+o6kvCBm7lEmv1CgM+Px/IhkNl7Yssl4wSZEmIo443wW/K9QcyPrhKAAqTVwr1fJlNXvekYqFENT5NnlUn8J6gik2ht/nnCYAONqKMyHqvPXcoRaAhmCOkfIYELC1bOH9F7VHv3nITBqRI8E/UGvrG8UV03BcBld3oRvL7jwkW5fooBenLdFgLIXAJhPUlk0pSp9Dg7h8RoHuT3hkqerNI9bHBYgIZnNK1rRdHA+Wzen5aekxrUqc1pkVPnCZnVkMRXupZFBlMGZn4cZgY0FdeI4lOYFrOXw850oOrf2IegfZET5AMzD14AK/gIfRlPDSvUsgtsc1Y3u018S1lToV5g==]]></content>
      <tags>
        <tag>英语</tag>
        <tag>随感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法课(4)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告四 Dijkstra算法（最短距离） &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目大意给出一张图，并给定起点和终点，问起点到终点的最短距离是多少？有两个特殊要求1）如果从顶点i到顶点j有不止一条最短路径，那么输出路段数最少者；2）如果具有最短路径并且路段数也是最少的路径至少有2条，那么输出按顶点编号的字典序最小者。 二、分析因为所有路径没有负边权，所以这里求最短路用的是Dijkstra算法。接下来简要的介绍一下Dijkstra。Dijkstra算法的思想就是从已经处理好的离起点最短距离转移到未访问点到起点的最短路。有点dp的味道。他用一个vis数组来区分这个点有没有被处理。用dis[i]数组存起点到i这个点的最短距离。用一个优先队列存储从以处理好的点组成的集合出发能到的点，类似于一个备选点，用优先队列维护其中离起点最近的那个点。一步步递推，最终处理出所有点到源点的最短距离。最后终点是什么就去找这个最短距离。 单纯找最短路径很简单。但怎么达到那两个额外的要求要转几个弯。问题一：怎么找路段最少的最短路？用一个ceng数组来记录起点到这个点经过几条边，类似于dinic分层图的感觉。 如果走多条边到一个点的dis值一致，那么就取层数最小的那个，并且记录前驱问题二：怎么找字典序最小的多段路？若是多段路的最少的路径有多条，怎么找出其中字典序最小的那个，我暂时没有想到什么比较巧妙的解法，就是最暴力的把可能的前驱全用set保存，最后一个dfs深搜，把所有可能的路径转为string类型，存在set里，那么set会自动排序，那么set中的第一个值就是字典序最小的答案。 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=3000;const int M=71000;set&lt;int&gt; pre[N];int ceng[N];int n,m;int dis[N];int vis[N];struct edge&#123; int to,v;&#125;;struct qnode&#123; int id; int v; bool operator &lt;(const qnode &amp;r)const &#123; return (v==r.v)?id&gt;r.id:v&gt;r.v; &#125;&#125;;vector&lt;edge&gt; G[N];void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); clr(ceng,INF); for(int i=0;i&lt;=n;i++) pre[i].clear(); priority_queue&lt;qnode&gt; q; dis[start] = 0; ceng[start] =0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to,w=G[u][i].v; if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(qnode&#123;v,dis[v]&#125;); pre[v].clear(); pre[v].insert(u); ceng[v]=ceng[u]+1; &#125; else if(dis[v]==dis[u]+w)&#123; if(ceng[v]&gt;=ceng[u]+1)&#123; pre[v].insert(u); ceng[v]=ceng[u]+1; &#125; &#125; &#125; &#125;&#125;/*void print_ans(int s)&#123; if(pre[s]==-1) &#123; cout&lt;&lt;s; return ; &#125; print_ans(pre[s]); cout&lt;&lt;"-&gt;"&lt;&lt;s;&#125;*/set&lt;string&gt; ans;void print_ans(int s,string ss)&#123; if(pre[s].empty()) ans.insert(ss); for(auto v:pre[s])&#123; print_ans(v,char(v+'0')+ss); //cout&lt;&lt;v&lt;&lt;endl; &#125;&#125;int main()&#123;/* freopen("input_spf.txt","r",stdin); freopen("output_spf.txt","w",stdout);*/ int cas=0; while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=n;j++)&#123; cin&gt;&gt;x; if(x!=-1) addedge(i,j,x); &#125; int s,t; cin&gt;&gt;s&gt;&gt;t; Dij(s); printf("Case %d\nThe least distance from %d-&gt;%d is %d\n",++cas,s,t,dis[t]); /* for(int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;" "&lt;&lt;pre[i]&lt;&lt;endl; */ ans.clear(); string sss=""; sss+=char(t+'0'); printf("Path: "); print_ans(t,""+sss); for(auto v:ans) &#123;sss=v;break;&#125; for(int i=0;i&lt;sss.size();i++) &#123; printf("%c%c%c",sss[i],"- "[i==sss.size()-1],"&gt;\n"[i==sss.size()-1]); &#125; &#125; return 0;&#125; 四、体会&ensp;&ensp;&ensp;&ensp;这题基于最短路算法，要找出最小段数且取字典序最小的最短路。首先最短路是很简单的，直接Dijkstra寻找最短路，这题的打印路径有点烦，一开始我看到只需要输出一条段数最小的路径，没注意要按照字典序排序，就直接记录一个前驱，输出了一条路径，但是这条路径不一定是字典序最小的，你要从所有满足条件的路径中找到那条字典序最小的路径，之后总的方向就两种：1，根据某种性质，只记录字典序最小的点的前驱；2，把所有满足条件的路径全找出来，然后找出字典序最小的那个。&ensp;&ensp;&ensp;&ensp;一开始，我尝试了第一种想法，实在没有什么办法，之后采取了第二种办法，暴力找路径，存set自动排序，总的过程类似于实验二，找出所有的路径，取set中的第一个。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(6)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%886%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告六 装载问题&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目大意 将n个体积分别为wi集装箱放置在容量分别为c1,c2的轮船中，问是否能有个合理放置的方案，若有，则输出字典序最大的方案。 二、分析题目可以转换为有n个元素，对于某个元素，有取或不取两个操作，取的集装箱总体积不超过c1,不取的集装箱总体积不超过c2,取或不取的问题可以dp做，爆搜当然也可以，但既然学到的搜索，就爆搜+减枝。因为要记录最佳的方案情况，而更新一次最佳方案需要$O(n)$的复杂度搜索每一种方案需要$O(2^n)$，所以总的复杂度是$O(n×2^n)$的复杂度，那如何将复杂度降为$O(2^n)$?做加法不做乘法。先找出第一艘船能装的满足条件的最多货物，之后在按先搜1再搜0的顺序搜索第一个满足条件的组合，因为是按1,0的顺序搜索的，所以第一个满足条件的方案一定是字典序最大的。简单来说就是 两次dfs。 三、代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;const int N=30;int a[N],b[N];int bestw=0;//int n; int c1,c2;int all;int fac[N],pre[N];int cnt=0;set&lt;string&gt; ans;void dfs1(int pos,int sum)&#123; if(pos==n+1) &#123; bestw=max(bestw,sum); return ; &#125; if(sum + fac[pos] &lt; bestw) return ; if(sum + a[pos] &lt;= c1) dfs1(pos+1,sum+a[pos]); if(pre[pos] - sum &lt;= c2) dfs1(pos+1,sum);&#125;void dfs2(int pos,int sum,string xx)&#123; if(pos==n+1) &#123; if(bestw==sum) ans.insert(xx); return ; &#125; if(sum + fac[pos] &lt; bestw) return ; if(sum + a[pos] &lt;= c1) dfs2(pos+1,sum+a[pos],xx+'1'); if(ans.size()) return ; if(pre[pos] - sum &lt;= c2) dfs2(pos+1,sum,xx+'0');&#125;int main()&#123; int cas=0; freopen("SOU_input.txt","r",stdin); freopen("SOU_output.txt","w",stdout); while(~scanf("%d",&amp;n))&#123; all=0;pre[0] = 0; cnt=0; ans.clear(); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); all+=a[i]; pre[i] = all; &#125; fac[n+1] = 0; for(int i=n;i&gt;=1;i--) fac[i] = fac[i+1] + a[i]; scanf("%d%d",&amp;c1,&amp;c2); printf("Case %d\n",++cas); bestw=-1; dfs1(1,0); dfs2(1,0,""); if(bestw==-1) &#123;puts("No");continue;&#125; cout&lt;&lt;bestw&lt;&lt;" "; auto v=ans.begin(); cout&lt;&lt;*v&lt;&lt;endl; &#125; return 0;&#125; 四、体会&ensp;&ensp;&ensp;&ensp;这次实验还是蛮有意思的，之前一直没有考虑到更新的答案的开销如何消除，但没想到只要先处理出答案，在去搜字典序最大的路径就可以了，两个dfs的复杂度都是$O(2^n)$,所以最后的总的复杂度也是$O(2^n)$。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>搜索</tag>
        <tag>算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(7)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%887%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告七 棋盘覆盖&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目大意 设n=$2^k$（k≥0）。在一个n×n个方格组成的棋盘中，恰有1个方格与其他方格不同，称该方格为特殊方格。显然，特殊方格在棋盘中可能出现的位置有4k种，因而有n2种不同的棋盘，下图所示是k=2，n=4时16种棋盘中的一个。 &ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp; 棋盘覆盖问题要求用下图所示的4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;易知，在任何一个n×n的棋盘中，用到的 L 型骨牌个数恰为 $(n^2-1)/3$。你的任务是给定k&gt;1，n=$2^k$设计一个算法实现棋盘的一种覆盖。 二、分析对于要解决的问题，例如下述的一张图 将他分为四块，则左上角的一个小区域可以递归求解，那么其他区域呢？ 只要在其他的方格的边界都加上一个黑块，就可以在填入一个黑块的前提下，将其他的区域也递归求解。 所以递归方程就是 T(n) = 4T(n/4)+O(1),复杂度为O(nlogn)。 问题就转换成了判断已经标号的方块在四个区域中的那个区域中。递归到长度为1时就直接返回。 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e3;int G[N][N];int flag=0;inline bool judge(int sx,int sy,int len,int bx,int by)&#123; return sx&lt;=bx&amp;&amp;bx&lt;sx+len&amp;&amp;sy&lt;=by&amp;&amp;by&lt;sy+len;&#125;void print(int sx,int sy,int k,int bx,int by)&#123; if(k==0) return ; int len=(1&lt;&lt;(k-1)); //四个小格子的尺寸 flag++; int x1,y1; if(judge(sx,sy,len,bx,by)) x1=bx,y1=by; //若已处理好的点在一号区，就记录这个坐标 else &#123;x1=sx+len-1;y1=sy+len-1;G[x1][y1]=flag;&#125; //若一号区没黑格，则为其右下角一个格子染色 int x2,y2; if(judge(sx+len,sy,len,bx,by)) x2=bx,y2=by; //同理 else &#123;x2=sx+len;y2=sy+len-1; G[x2][y2]=flag;&#125; //......右上角 int x3,y3; if(judge(sx,sy+len,len,bx,by)) x3=bx,y3=by; else &#123;x3=sx+len-1;y3=sy+len; G[x3][y3]=flag;&#125; // ......左下角 int x4,y4; if(judge(sx+len,sy+len,len,bx,by)) x4=bx,y4=by; else &#123;x4=sx+len;y4=sy+len; G[x4][y4]=flag;&#125; // .....左上角//递归的去处理这四个小方格，参数是已处理好的那个格子的坐标 print(sx,sy,k-1,x1,y1); print(sx+len,sy,k-1,x2,y2); print(sx,sy+len,k-1,x3,y3); print(sx+len,sy+len,k-1,x4,y4);&#125;int main()&#123; int x,y,bx,by,k; int cas=0; while(~scanf("%d%d%d",&amp;k,&amp;bx,&amp;by))&#123; memset(G,0,sizeof G); flag=0; printf("Case %d:n=%d\n",++cas,(1&lt;&lt;(k-1))); print(1,1,k,bx,by); for(int i=1;i&lt;=(1&lt;&lt;k);i++) for(int j=1;j&lt;=(1&lt;&lt;k);j++)&#123; if(i==bx&amp;&amp;j==by)printf(" #%c"," \n"[j==(1&lt;&lt;k)]); else printf("%2d%c",G[i][j]," \n"[j==(1&lt;&lt;k)]); &#125; &#125; return 0;&#125; 四、运行结果数据1 2 12 2 33 1 1 五、实验体会&ensp;&ensp;&ensp;这是个经典的递归程序，有很多的细节需要考虑，比如填色的计数器该如何设置，作为参数传递下去？还是作为一个全局变量？还有如何判断已经染色的方格的位置？虽然思路比较简单，但真正判断起来还是要非常仔细的，一些边界值要仔细的计算。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法课</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(5)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%885%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告五 跳马问题&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目大意 给定88方格棋盘，求棋盘上一只马从一个位置到达另一位置的*最短路径长。注意马是走“日”形的。 二、分析这是一道显然的搜索题，用dfs或bfs均可，但bfs更加简单，广搜更加容易理解。某一点的到起点的最短距离一定是从某一个合法位置跳到这个点的，从起点bfs，如果设当前的点是u，能到达的点是v，那么v到起点的最短距离=u到起点的最短距离+1（u到v的距离）。那么对于一个u 有哪几个v呢？||v|| v| || —| —|—|—|—||v||||v||||u||v||||v|||v||v|如上表，有八个方向，记录一下两维的偏移量。使用一个vis数组，记录这个点访问过了没。具体操作而言，从某起点出发，对每个点广度搜索，若这个点访问过了，则跳过这个点，否则搜索它可以到达的所有点，更新vis数组，更新到起点需要几步，入队列，重复操作，知道，队列为空。这题基本就是这样做的，但数据量较少，我直接暴力枚举所有起点，求这个起点，到所有点的跳动次数。 三、代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=0x3f3f3f3f;bool vis[9][9];int dis[9][9][9][9];typedef pair&lt;int,int&gt; PII;#define X first#define Y second#define clr(x,y) memset(x,0,sizeof(x) )int dx[]=&#123;1,-1,1,-1,2,-2,2,-2&#125;;int dy[]=&#123;2,2,-2,-2,1,1,-1,-1&#125;;void bfs(int x,int y)&#123; clr(vis,0); clr(dis[x][y],INF); dis[x][y][x][y]=0; queue&lt;PII&gt; q; q.push(PII(x,y)); while(!q.empty())&#123; PII cur=q.front(); q.pop(); int xx=cur.X,yy=cur.Y; for(int i=0;i&lt;8;i++)&#123; int xxx=dx[i]+xx,yyy=dy[i]+yy; if(xxx&lt;0||xxx&gt;8||yyy&lt;0||yyy&gt;8||vis[xxx][yyy]) continue; vis[xxx][yyy]=1; dis[x][y][xxx][yyy] = dis[x][y][xx][yy] + 1; q.push(PII(xxx,yyy)); &#125; &#125;&#125;char from[5],to[5];int main()&#123; for(int i=1;i&lt;=8;i++) for(int j=1;j&lt;=8;j++) bfs(i,j); while(~scanf("%s %s",from,to))&#123; int x=from[0]-'a'+1; int y=from[1]-'0'; int xx=to[0]-'a'+1; int yy=to[1]-'0'; printf("%s==&gt;%s: %d moves\n",from,to,dis[x][y][xx][yy]); &#125; return 0;&#125; 四、体会&ensp;&ensp;&ensp;&ensp;这次是一个基础的bfs，与一些迷宫问题或是在方格上求最短距离不同，它有八个方向，然而本质是不变的，都是记录访问状态vis和离起点最短距离，当然全部暴力用bfs打表出来在数据量大的时候肯定不行，到时候可能要对一个个询问依次处理，要用到更高效的搜索，比如双向bfs，或者启发式搜索。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>bfs</tag>
        <tag>算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛区域赛备战--模板及复习--简单算法]]></title>
    <url>%2Funcategorized%2F%E9%9D%92%E5%B2%9B%E5%8C%BA%E5%9F%9F%E8%B5%9B%E5%A4%87%E6%88%98--%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%A4%8D%E4%B9%A0--%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[青岛区域赛备战—模板及复习—简单算法1、快速幂2、LIS及其变形 快速幂1234567LL Pow(LL a, LL n, LL mod)&#123; LL t = 1; for (; n; n &gt;&gt;= 1, a = (a * a % mod)) if (n &amp; 1) t = (t * a % mod); return t;&#125; LIS1234567891011121314151617181920int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;在从小到大的排序数组中，lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 点分治点分治还是很有意思的，不过自己看博客还是比较吃力的，看了好久。基本思想：找一颗树上的重心（所有以此点为根的子树中最大子树最小的那个根结点）分治解决。（这是关键。）详细解释一下：一开始结点数为n，朴素算法O($n^2$)，若找重心分治处理就是O($log(n)$)层，每次合并时间是（这里是O(nlog(n)+n) 排序+找最远可行对）不定。那最终就是O(nlog(n)log(n)).最终的决定权基本在合并算法的手里，能合并，就能处理。需要注意的是1ans-=solve(v,w); 要减掉没有经过根的点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=40010;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top]=Edge&#123;c,b,head[a]&#125;; head[a]=top++;&#125;void init()&#123; top=0; memset(head,-1,sizeof(head));&#125;int k;int root,sim[N],S,mxson[N];int MX,vis[N];void getroot(int u,int fa)&#123; sim[u]=1;mxson[u]=0; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int w=edge[i].val; if(v==fa||vis[v]) continue; getroot(v,u); sim[u]+=sim[v]; mxson[u]=max(mxson[u],sim[v]); &#125; mxson[u] = max(mxson[u],S-sim[u]); if(mxson[u]&lt;MX)&#123; MX=mxson[u]; root=u; &#125;&#125;LL ans;int id;int dis[N]; //到重心的距离void getdis(int u,int fa,int dist) //点u到root的距离&#123; dis[id++] = dist; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(v==fa||vis[v]) continue; getdis(v,u,dist+w); &#125;&#125;int solve(int u,int len)&#123; //排序找符合的点 id=0; clr(dis,0); getdis(u,0,len); sort(dis,dis+id); int L=0,R=id-1; int tmp=0; while(L&lt;R)&#123; if(dis[R]+dis[L]&lt;=k)&#123;tmp+=R-L;L++;&#125; else R--; &#125; return tmp;&#125;void Divide(int u)&#123; ans+=solve(u,0); vis[u]=true; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(vis[v]) continue; ans-=solve(v,w); S=sim[v];root=0; MX=INF;getroot(v,0); Divide(root); &#125;&#125;int main()&#123; int n; while(scanf("%d%d",&amp;n,&amp;k),n+k)&#123; init(); int a,b,c; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); addedge(b,a,c); &#125; clr(vis,0); S=n,MX=INF; root=0;ans=0; getroot(1,0); Divide(root); printf("%lld\n",ans); &#125; return 0;&#125; LGV 注意条件转移。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛区域赛备战--模板及复习--dp]]></title>
    <url>%2Funcategorized%2F%E9%9D%92%E5%B2%9B%E5%8C%BA%E5%9F%9F%E8%B5%9B%E5%A4%87%E6%88%98--%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%A4%8D%E4%B9%A0--dp%2F</url>
    <content type="text"><![CDATA[青岛区域赛备战—模板及复习—dp区间dp12345for(.....)//枚举起点for(.....)//枚举长度 //处理区间或 dfs写法dp方程随缘 状压dp *看清维数，弄清楚转移方向啊 数位dp12345678910111213141516171819202122232425262728293031323334353637383940typedef long long LL;int a[20];LL dp[20][state];LL dfs(int pos,/*state变量*/,bool limit/*数位上界变量*/)&#123; if(pos==-1) return 1; if(!limit &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; int up=limit?a[pos]:9; LL ans=0; for(int i=0;i&lt;=up;i++) &#123; if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,limit &amp;&amp; i==a[pos]) &#125; if(!limit ) dp[pos][state]=ans; return ans;&#125;LL solve(LL x)&#123; int pos=0; while(x) &#123; a[pos++]=x%10; x/=10; &#125; return dfs(pos-1/*从最高位枚举*/, /*一系列状态 */ ,true);&#125;int main()&#123; LL le,ri; memset(dp,-1,sizeof dp); while(~scanf("%lld%lld",&amp;le,&amp;ri)) &#123; printf("%lld\n",solve(ri)-solve(le-1)); &#125;&#125; 背包1234567891011121314151617181920212223242526272829303132333435363738394041//01背包for(i=1;i&lt;=N;i++)&#123; for(j=V;j&gt;=c[i];j--)&#123; f[j]=max(f[j],f[j-c[i]]+w[i]); &#125;&#125;//完全背包for(i=1;i&lt;=N;i++)&#123; for(j=c[i];j&lt;=V;j++)&#123; f[j]=max(f[j],f[j-c[i]]+w[i]); &#125;&#125;//多重背包 二进制优化for(i=0;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;wi,&amp;vi,&amp;c); for(j=1;j&lt;=c;j&lt;&lt;=1)&#123; v.push_back(j*vi); w.push_back(j*wi); c=c-j; &#125; if(c&gt;0)&#123; v.push_back(c*vi); w.push_back(c*wi); &#125;&#125;for(i=0;i&lt;v.size();i++)&#123; for(j=W;j&gt;=w[i];j--)&#123; dp[j]=max(dp[j-w[i]]+v[i],dp[j]); &#125;&#125;//分组背包for(int i=0;i&lt;n;i++)&#123;//n是分组数 for(int j=V;j&gt;=0;j--)&#123;//V是背包体积 for(int k=0;k&lt;num[i];k++)&#123;//num[i]是第i组物品的数量 if(j&gt;=w[i][k])dp[j]=max(dp[j-w[i][k]]+v[i][k],dp[j])//w[i][k]是第i组第k个物品的体积 &#125; &#125;&#125; dp随缘]]></content>
      <tags>
        <tag>acm</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[青岛区域赛备战--模板及复习--图论]]></title>
    <url>%2Funcategorized%2F%E9%9D%92%E5%B2%9B%E5%8C%BA%E5%9F%9F%E8%B5%9B%E5%A4%87%E6%88%98--%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%A4%8D%E4%B9%A0--%E5%9B%BE%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[青岛区域赛备战—模板及复习—图论连通性有向图强连通缩点 所需数组 $idx,low[MAXN],dfn[MAXN]$——————时间戳和两个访问标志$sccno ,scc[MAXN]$ ————点属于哪个连通分支，及连通分量数量$stack st ,inst[MAXN]$————栈，一个中间工具，用于分辨点属于哪个连通分量$vector G[MAXN];$————图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N = 40000;const int M = 500000;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int idx,low[N],dfn[N];int sccno,scc[N];stack&lt;int&gt;st; int inst[N];void tarjan_init()&#123; init(); clr(dfn,0); clr(inst,0); clr(scc,0); sccno=idx=0; while(!st.empty()) st.pop();&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++idx; st.push(x); inst[x]=1; for(int i=head[x];~i;i=edge[i].next) &#123; int v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[x]=min(low[v],low[x]); &#125; else if(inst[v])&#123; low[x]=min(low[x],dfn[v]); &#125; &#125; if(low[x]==dfn[x])&#123; ++sccno; int v; while(1)&#123; v=st.top(); st.pop(); inst[v]=0; scc[v] = sccno; if(x==v) break; &#125; &#125;&#125; 割边&amp;&amp;割点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//割点const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int low[N],dfn[N],idx;int iscut[N];int rootson;void tarjan_init()&#123; init(); clr(dfn,0); idx=rootson=0; clr(iscut,0);&#125;void tarjan(int u,int pre,int id)&#123; dfn[u]=low[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; if(!dfn[v])&#123; tarjan(v,u,i); if(u==1) rootson++; else &#123; low[u]=min(low[u],low[v]); if(low[v]&gt;=dfn[u]) iscut[u]=1; &#125; &#125;else&#123; low[u]= min(low[u],dfn[v]); &#125; &#125;&#125;if(rootson&gt;1) iscut[1]=1;//调用后 加一句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//割边const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int low[N],dfn[N],idx;int fa[N],isbridge[N];int bridge;void tarjan_init()&#123; init(); clr(dfn,0); bridge=idx=0; clr(isbridge,0); clr(fa,0);&#125;void tarjan(int u,int pre,int id)&#123; fa[u]=pre; low[u]=dfn[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; //...... if(!dfn[v])&#123; tarjan(v,u,i); low[u]=min(low[u],low[v]); if(low[v] &gt; dfn[u]) &#123; isbridge[v]=1,bridge++; //cout&lt;&lt;"isbridge"&lt;&lt;endl; &#125; &#125; else if(v!=pre)&#123; //。。。。。 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125;//注意isbridge数组与fa数组一起用，且若isbridge[i]，则i和fa[i]是割边//重边要不要注意写法 割边割点注意=号 最短路单源最短路dij$O((E+N)logN)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N=3000;const int M=71000;int n,m;int dis[N];int vis[N];struct edge&#123; int to,v;&#125;;struct qnode&#123; int id; int v; bool operator &lt;(const qnode &amp;r)const &#123; return v&gt;r.v; &#125;&#125;;vector&lt;edge&gt; G[N];void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to,w=G[u][i].v; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(qnode&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//前向星模板 防止类似poj老oj卡vector 一般不用const int N=40010;const int M=150010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];struct qnode&#123; int id; int dis; bool operator &lt;(const qnode &amp;r)const &#123; return dis&gt;r.dis; &#125;&#125;;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to,w=edge[i].val; if(!vis[v]&amp;&amp;dis[v] &gt; w+dis[u])&#123; dis[v] = w+dis[u]; q.push(qnode&#123; v,dis[v]&#125;); &#125; &#125; &#125;&#125; spfa$O(km)$ k最坏情况下是n 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N=10010;const int M=500010;int n,m;int dis[N];struct edge&#123; int to;int v;&#125;;vector&lt;edge&gt; G[N];int vis[N];int cnt[N];//每个点的入队次数void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int cost=G[u][i].v; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859前向星const int N=50010;const int M=50010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];int cnt[N];//每个点的入队次数int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int cost=edge[i].val; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 12345678//读入优化 哎 pojinline LL read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125; 差分约束给定一串序列，长度为n。$a_1,a_2,a_3……a_n$并给定m的限制条件，条件的格式为$a_i-a_j&lt;=c$求$a_n-a_1$的最大值考虑序列三个数a，b，c$a-b&lt;=v_1$$b-c&lt;=v_2$$a-c&lt;=v_3$$\Longrightarrow a-c&lt;=min(v_3,(v_1+v_2))$这个缩小约束条件的过程就是求最短路的过程所以可以用最短路模型来解决 模型1.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&lt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最大可能差值？方法：对于每个限制条件$a_i - a_j&lt;=c$，从点j到点i建立一条边(c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。 推广 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？就是反一反$a-b&gt;=v_1$$b-c&gt;=v_2$$a-c&gt;=v_3$$\Longrightarrow a-c&gt;=max(v_3,(v_1+v_2))$要满足所有条件，（a-c的）范围扩大，求最长路 模型2.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_i - a_j&gt;=c$，从点j到点i建立一条边(c)，求$a_{k2}$ 到 $a_{k1}$ 的最长路即可。 条件转换：$a-b&lt;=c \Longrightarrow b-a&gt;=c$$a-b=c \Longrightarrow a-b&lt;=c , b-a&lt;=c$….(简单数学变换) 模型2也可转换为模型1$a-b&gt;=v_1$ ``_1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$b-c&gt;=v_2 \Longrightarrow$ $c-b&lt;=-v_2$$a-c&gt;=v_3$ ```````$c-a&lt;=-v_3$求$a_&#123;k2&#125;$ 到 $a_&#123;k1&#125;$ 的最短路**模型2优化.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_&#123;k1&#125;$ 与 $a_&#123;k2&#125;$ 的最小可能差值？方法：对于每个限制条件$a_j - a_i&lt;=-c$，从点i到点j建立一条边(-c)，求$a_&#123;k1&#125;$ 到 $a_&#123;k2&#125;$ 的最短路即可。**对于一个求最短路（最长路）约束条件有可能有三种情况：1.有上界，即有解2.无解（有负环）3.任意多的解（约束条件不够强，或者说图不强连通）有解就是最短路无解就是有负环，最短路负无穷大无穷解就是不连通，最短路正无穷大题目集：最长路（模板题）https://blog.csdn.net/wyxxzsy/article/details/82777158再提一句，超级源点，一开始对于网上加入超级源点，直接计算最短路很不理解，因为加入超级源点之后，源点到每个点的距离至多是0,所以我一度认为，加入超级源点只是为了图的连通性，判断负环而已。但在最长路模型里不一样，它的权值都是负的，正确的权值是-dis[v],0到反而是最小值（加负号后）了，不会影响答案，有意思。## 2-sat拆点+建模```c++int low[N&lt;&lt;1],dfn[N&lt;&lt;1],idx;stack&lt;int&gt; st;int inst[N&lt;&lt;1];int scc[N&lt;&lt;1],sccno;vector&lt;int&gt; G[N&lt;&lt;1];int n;void init()&#123; for(int i=0;i&lt;=2*n;i++) G[i].clear(); while(!st.empty()) st.pop(); clr(dfn,0); clr(inst,0); idx=sccno=0;&#125;void tarjan(int x)&#123; low[x] = dfn[x]=++idx; st.push(x); inst[x]=1; for(int i=0;i&lt;G[x].size();i++) &#123; int v=G[x][i]; if(!dfn[v])&#123; tarjan(v); low[x] = min(low[v],low[x]); &#125; else if(inst[v])&#123; low[x]= min(low[x],dfn[v]); &#125; &#125; if(low[x]==dfn[x])&#123; ++sccno; int v; do&#123; v=st.top(); st.pop(); inst[v]=0; scc[v]=sccno; &#125;while(x!=v); &#125;&#125;bool solve()&#123; for(int i=0;i&lt;2*n;i++) if(!dfn[i]) tarjan(i); for(int i=0;i&lt;2*n;i+=2) &#123; if(scc[i]==scc[i^1]) return false; &#125; return true;&#125; 网络流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const int MAXN = 100010;//点数的最大值const int MAXM = 400010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;//加边,单向图三个参数,双向图四个参数void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;//输入参数:起点、终点、点的总数//点的编号没有影响,只要输入点的总数int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; &#125; return ans;&#125; LCA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10050;int rmq[maxn * 2];struct ST &#123; int mm[2 * maxn]; int dp[2 * maxn][20]; void init(int n) &#123; mm[0] = -1; for(int i = 1; i &lt;= n; i++) &#123; mm[i] = ((i &amp; (i - 1)) == 0) ? mm[i - 1] + 1 : mm[i - 1]; dp[i][0] = i; &#125; for(int j = 1; j &lt;= mm[n]; j++) &#123; for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; i++) &#123; dp[i][j] = rmq[dp[i][j - 1]] &lt; rmq[dp[i + (1 &lt;&lt; (j - 1))][j - 1]] ? dp[i][j - 1] : dp[i + (1 &lt;&lt; (j - 1))][j - 1]; &#125; &#125; &#125; int query(int a, int b) &#123; if(a &gt; b) swap(a, b); int k = mm[b - a + 1]; return rmq[dp[a][k]] &lt;= rmq[dp[b - (1 &lt;&lt; k) + 1][k]] ? dp[a][k] : dp[b - (1 &lt;&lt; k) + 1][k]; &#125;&#125; st;vector&lt;int&gt; g[1005];int tot;int F[maxn * 2];//欧拉序int P[maxn * 2];//节点i在F中第一次出现的位置bool used[maxn];void init() &#123; for(int i = 0; i &lt; 2000; i++) g[i].clear(); memset(used, 0, sizeof(used));&#125;void dfs(int x, int pre, int dep) &#123; F[++tot] = x; rmq[tot] = dep; P[x] = tot; for(int i = 0; i &lt; g[x].size(); i++) &#123; int s = g[x][i]; if(s != pre) &#123; dfs(s, x, dep + 1); F[++tot] = x; rmq[tot] = dep; &#125; &#125;&#125;void LCA_init(int root, int n) &#123; tot = 0; dfs(root, root, 0); st.init(2 * n - 1);&#125;int lca(int u, int v) &#123; return F[st.query(P[u], P[v])];&#125;int main() &#123; int t; cin &gt;&gt; t; int k = 1; while(t--) &#123; init(); int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; int m; scanf("%d", &amp;m); if(m == 0) continue; for(int j = 1; j &lt;= m; j++) &#123; int a; scanf("%d", &amp;a); g[i].push_back(a); g[a].push_back(i); used[a] = true; &#125; &#125; int q; scanf("%d", &amp;q); printf("Case %d:\n", k++); int root; for(int i = 1; i &lt;= n; i++) &#123; if(!used[i]) &#123; root = i; break; &#125; &#125; LCA_init(root, n); while(q--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); printf("%d\n", lca(u, v)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(3)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告三 哈夫曼编码&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目大意 给定n个数的出现频率，问几个数的哈夫曼编码是多少？在构造Huffman树的过程中有些要求：1．左儿子标记为0，右儿子标记为1；2．左儿子的权值&gt;=右儿子的权值；3．相同权值w的两个字母x、y，出现时间晚的优先级高。 二、分析那这其实就是贪心+模拟。用什么模拟？ 优先队列，也就是堆。何为模拟？每次弹出堆中最小的两个值，合并成一个权值为两最小权值之和的新节点，并维护左右孩子，并插入堆中。可以得知，插入堆的节点需要有这么几个参数：时间戳，频次，左孩子，右孩子。123456789struct node&#123; int id; int lid,rid; int val; bool operator&lt;(const node&amp;q)const&#123; if(val==q.val) return id&lt;q.id; return val&gt;q.val; &#125;&#125;a[1&lt;&lt;13]; 那么为了构造唯一Huffman树，需要重载比较运算符：若频次一致，则插入时间晚的点优先级高，否则频次低的点优先级高。构造出Huffman树后，再从根节点往下递归，左枝加‘0’，右枝加‘1’，遇到树叶，记忆化并返回。最后按1~n的时间戳输出叶子节点与其编码即可。 三、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int,int&gt; PII;const int INF = 0x3f3f3f3f;struct node&#123; int id; int lid,rid; int val; bool operator&lt;(const node&amp;q)const&#123; if(val==q.val) return id&lt;q.id; return val&gt;q.val; &#125;&#125;a[1&lt;&lt;13];priority_queue&lt;node&gt; q;string ans[1&lt;&lt;13];void dfs(node s,string tmp)&#123; if(s.lid!=-1)&#123; ans[s.lid]=tmp+'0'; dfs(a[s.lid],ans[s.lid]); &#125; if(s.rid!=-1)&#123; ans[s.rid]=tmp+'1'; dfs(a[s.rid],ans[s.rid]); &#125;&#125;int main()&#123; int t;scanf("%d",&amp;t); int cas=0; while(t--)&#123; while(!q.empty()) q.pop(); int n;scanf("%d",&amp;n); for(int i=1,x;i&lt;=n;i++)&#123; cin&gt;&gt;x; a[i] = node&#123;i,-1,-1, x&#125;; q.push(a[i]); &#125; int id=n; while(q.size()!=1)&#123; node r=q.top();q.pop(); node l=q.top();q.pop(); id++; a[id] = node&#123;id,l.id,r.id,r.val+l.val&#125;; q.push(a[id]); &#125; node s=q.top();q.pop(); for(int i=0;i&lt;(1&lt;&lt;13);i++) ans[i].clear(); dfs(s,""); printf("Case %d\n",++cas); for(int i=1;i&lt;=n;i++) cout&lt;&lt;a[i].val&lt;&lt;" "&lt;&lt;ans[i]&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125; 四、体会&ensp;&ensp;&ensp;&ensp;这是做到现在为止最简单的实验了，只需要按照给定的规则构造堆，再合并两个权值最小的点，直到合并到一个点。最后再一个dfs深搜构造答案即可。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>算法课</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(2)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告二 最长公共子序列&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题目要求 求两个字符串a，b的最长公共子序列的长度，并打印出所有成立的子序列 二、分析这是一道典型的动态规划+路径记录的题。一般解决动态规划的路径打印，都是在动态规划的过程中记录达到这个状态的直接前驱，最后用一个深度搜索从末状态逆推前状态，再此过程中打印出答案。这道题的难点是要把所有的可能序列全打印出来，这该如何解决呢？ 先不急，先把基础的转移方程写出来两个串分别为a，b。定义状态$dp[i][j] ：a串的前i个字符组成的字符串和b串前j个字符组成的字符串的最长公共子序列的长度$ 状态转移方程 $dp[i][j]\begin{cases} &amp; \text 0 \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;{}if\; i=0||j=0\\ &amp; \text dp[i-1][j-1]+1\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;if\;i,j&gt;0,x_i=y_i \\ &amp; max(dp[i][j-1],dp[i-1][j]) \;\;\;\;\;if\;i,j&gt;0,x_i\neq y_i\end{cases}$两个字符串的尾部字符若是相同直接等于去掉尾部字符的情况下的答案加1。若是不同，取去掉一个末尾后情况最多的那个状态的答案。 初始化状态$dp_{0-n.0}=0$$dp_{0.0-m}=0$很容易想嘛，若是一个序列前0个字符肯定不能和任何字符有公共子序列。 那怎么打印所有的可能序列呢？要输出所有的情况，不能仅仅记录一个前驱，要将所有的可能的状态前驱全部记录下来。最后在输出答案的时候，dfs每一个前驱，到递归边界的时候记录答案，这里最好用set保存，去重。 三、代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int,int&gt; PII;const int INF = 0x3f3f3f3f;const int N=55;char a[N],b[N];int dp[N][N];map&lt;PII,set&lt;PII&gt; &gt; pre;set&lt;string&gt; ans;int len;void dfs(int n,int m,string tmp)&#123; if(!n||!m) ans.insert(tmp); for(auto v:pre[PII(n,m)])&#123; int x=v.X,y=v.Y; if(a[n]==b[m]) dfs(x,y,a[n]+tmp); else dfs(x,y,tmp); &#125;&#125;int main()&#123; int t;scanf("%d",&amp;t); int cas=0; while(t--)&#123; int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=m;i++) cin&gt;&gt;b[i]; clr(dp,0); pre.clear(); ans.clear(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(a[i]==b[j]) &#123; dp[i][j] = dp[i-1][j-1] + 1; pre[PII(i,j)].insert(PII(i-1,j-1)); &#125; else &#123; if(dp[i-1][j]&gt;dp[i][j-1])&#123; dp[i][j] = dp[i-1][j]; pre[PII(i,j)].insert(PII(i-1,j)); &#125;else if(dp[i-1][j]&lt;dp[i][j-1])&#123; dp[i][j] = dp[i][j-1]; pre[PII(i,j)].insert(PII(i,j-1)); &#125;else&#123; dp[i][j] = dp[i][j-1]; pre[PII(i,j)].insert(PII(i,j-1)); pre[PII(i,j)].insert(PII(i-1,j)); &#125; &#125; &#125; len=dp[n][m]; dfs(n,m," "); cout&lt;&lt;ans.size()&lt;&lt;endl; for(auto v:ans)&#123; cout&lt;&lt;v&lt;&lt;endl; &#125; &#125; return 0;&#125; 四、体会&ensp;&ensp;&ensp;&ensp;这次实验也比较简单,dp方程还是很好推的,而且记录路径也是非常常见的,没有什么恶心的处理。尤其n&lt;=50,即使在记录路径的时候处理的不是很好,dfs写的常数比较大,也不会超时,几乎只要想到了,就能写出来了。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法课(1)]]></title>
    <url>%2Funcategorized%2F%E7%AE%97%E6%B3%95%E8%AF%BE%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算法报告一 矩阵链乘&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;16122020 &ensp;&ensp;钟顺源 一、题意 给定n个矩阵，问如何加括号使总的计算次数最少？输入给的是长度为n+1的序列$a_{1:(n+1)}$。即矩阵$A_i$的行数为$a_i$,列数为$a_{i+1}$输出总的计算次数和加括号的方案。 二、分析&ensp;&ensp; n的范围很小只有20,所以严格来说哪怕dp开四五维在时间上都是可以的，但没必要，这是非常经典的一道区间dp，只需开两维。 dp[i][j] : 第i个矩阵到第j个矩阵 矩阵链乘的最小值。 那么i～j这个区间可以从两个更小的区间转移而来。 需要注意一下前一区间的尾部的列就等于后一区间尾的行所以在合并区间的时候要前一区间头的行×（前一区间尾的列/后一区间尾的行）×后一区间尾的列 若i!=j $dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+a[i]a[k+1]a[j+1])$若i==j $dp[i][j]=0$ 推出dp转移方程后，另一个难点是要输出解决方案。要记录当前区间 a[i:j] 的最小链乘值是从哪两个小区间合并而来。另开一个数组pre[i][j] 来记录k。在输出时只要以k为分割点递归调用，就可以输出方案了。 三、ac代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;typedef unsigned long long ull;const int mod=1e9+7;const int INF=0x3f3f3f3f;int dp[30][30];int a[30];int pre[30][30];int n;int dfs(int l,int r) //第l个到第r个范围内的答案&#123; if(dp[l][r]) return dp[l][r]; if(r-l &lt;1) return 0; int &amp;ans=dp[l][r]; ans=INF; for(int i=l; i&lt;r; i++) if(ans&gt;dfs(l,i)+dfs(i+1,r)+a[i+1]*a[l]*a[r+1]) ans = dfs(l,i)+dfs(i+1,r)+a[i+1]*a[l]*a[r+1], pre[l][r] = i; return ans;&#125;void print_ans(int l,int r)&#123; if(r==l) printf("A%d",l); else &#123; int flag=(l!=1||r!=n); if(flag) printf("("); print_ans(l,pre[l][r]); print_ans(pre[l][r]+1,r); if(flag) printf(")"); &#125;&#125;int main()&#123; int cas=0; while(~scanf("%d",&amp;n)) &#123; clr(dp,0); for(int i=1; i&lt;=n+1; i++) scanf("%d",&amp;a[i]); printf("Case %d\n%d ",++cas,dfs(1,n)); print_ans(1,n); printf("\n"); &#125; return 0;&#125; 四、体会&ensp;&ensp; 这次的题目还算简单，dp方程很明显，不过需要处理的是输入和输出解决方案，就是在dp中要记录路径，才能转移到要求的区间。这题用了记忆化搜索的dp写法，在边界的判断上有点不够舒服，改了好久。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>算法课</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 372C 单调队列优化dp]]></title>
    <url>%2Funcategorized%2FpoCodeForces-372C-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96dp%2F</url>
    <content type="text"><![CDATA[第二道 单调dp题单调队列只是辅助，dp是关键，写出合理的dp方程才知道并用单调队列优化。大意：1-n 个地点 ，放m次烟花 ，每次可走d的长度 （可以不是必须）给出m次烟花的参数a[i] —-烟花地点 b[i]—第i次烟花的一个参数，没什么实际意义 t[i]—-燃放烟花的时间每放一次烟花，这个人就会得到 bi - |ai - x| 的权值 x是当时的位置给出状态方程：dp[i][j]：第i次燃放烟花时，且人在j 时的最大值。 dp[i][j] 可以转移到什么状态 ——&gt; dp[i+1][k]dp[i][j] = max(dp[i][k]) + b[i] -|a[i]-j|就是说 我现在可以从k 的位置走到 j，并加上相应的权值。那么k会受到 t[i] -t[i-1] 和 d 的限制限制是什么？$\Delta t = t_i - t_{i-1}$$ k \epsilon \left [ max(0,j-\Delta t d) ,min(n,j+\Delta t d)\right ] $ dp[i][j] = max(dp[i-1][k]) + b[i] - |a[i]-j|搞清楚了状态转移方程和一些细节问题，怎么优化呢？]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树分治———点分治]]></title>
    <url>%2Funcategorized%2F%E6%A0%91%E5%88%86%E6%B2%BB%E2%80%94%E2%80%94%E2%80%94%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[树分治———点分治点分治还是很有意思的，不过自己看博客还是比较吃力的，看了好久。基本思想：找一颗树上的重心（所有以此点为根的子树中最大子树最小的那个根结点）分治解决。（这是关键。）详细解释一下：一开始结点数为n，朴素算法O($n^2$)，若找重心分治处理就是O($log(n)$)层，每次合并时间是（这里是O(nlog(n)+n) 排序+找最远可行对）不定。那最终就是O(nlog(n)log(n)).最终的决定权基本在合并算法的手里，能合并，就能处理。需要注意的是1ans-=solve(v,w); 要减掉没有经过根的点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=40010;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top]=Edge&#123;c,b,head[a]&#125;; head[a]=top++;&#125;void init()&#123; top=0; memset(head,-1,sizeof(head));&#125;int k;int root,sim[N],S,mxson[N];int MX,vis[N];void getroot(int u,int fa)&#123; sim[u]=1;mxson[u]=0; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int w=edge[i].val; if(v==fa||vis[v]) continue; getroot(v,u); sim[u]+=sim[v]; mxson[u]=max(mxson[u],sim[v]); &#125; mxson[u] = max(mxson[u],S-sim[u]); if(mxson[u]&lt;MX)&#123; MX=mxson[u]; root=u; &#125;&#125;LL ans;int id;int dis[N]; //到重心的距离void getdis(int u,int fa,int dist) //点u到root的距离&#123; dis[id++] = dist; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(v==fa||vis[v]) continue; getdis(v,u,dist+w); &#125;&#125;int solve(int u,int len)&#123; //排序找符合的点 id=0; clr(dis,0); getdis(u,0,len); sort(dis,dis+id); int L=0,R=id-1; int tmp=0; while(L&lt;R)&#123; if(dis[R]+dis[L]&lt;=k)&#123;tmp+=R-L;L++;&#125; else R--; &#125; return tmp;&#125;void Divide(int u)&#123; ans+=solve(u,0); vis[u]=true; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to;int w=edge[i].val; if(vis[v]) continue; ans-=solve(v,w); S=sim[v];root=0; MX=INF;getroot(v,0); Divide(root); &#125;&#125;int main()&#123; int n; while(scanf("%d%d",&amp;n,&amp;k),n+k)&#123; init(); int a,b,c; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); addedge(a,b,c); addedge(b,a,c); &#125; clr(vis,0); S=n,MX=INF; root=0;ans=0; getroot(1,0); Divide(root); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>分治</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下界网络流]]></title>
    <url>%2Funcategorized%2F%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[转载自：https://www.cnblogs.com/mlystdcall/p/6734852.html【教程】上下界网络流建模方法总结前言 之前学习上下界网络流的时候，花了很多时间去理解建模的方式和原理，然而今天复习的时候发现忘得差不多了QwQ。于是参考了一下以前的代码，再次做了个总结，放在博客里，省得以后忘掉QwQ。 无源汇可行流 建模方法： 首先建立一个源ss和一个汇tt，一般称为附加源和附加汇。 对于图中的每条弧，假设它容量上界为c，下界b，那么把这条边拆为三条只有上界的弧。 一条为，容量为b； 一条为，容量为b； 一条为，容量为c−b。 其中前两条弧一般称为附加弧。 然后对这张图跑最大流，以ss为源，以tt为汇，如果所有的附加弧都满流，则原图有可行流。 这时，每条非附加弧的流量加上它的容量下界，就是原图中这条弧应该有的流量。 理解方法： 对于原图中的每条弧，我们把c−b称为它的自由流量，意思就是只要它流满了下界，这些流多少都没问题。 既然如此，对于每条弧，我们强制给v提供b单位的流量，并且强制从u那里拿走b单位的流量，这一步对应着两条附加弧。 如果这一系列强制操作能完成的话，也就是有一组可行流了。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。有源汇可行流 建模方法： 建立弧，容量下界为0，上界为∞。 然后对这个新图（实际上只是比原图多了一条边）按照无源汇可行流的方法建模，如果所有附加弧满流，则存在可行流。 求原图中每条边对应的实际流量的方法，同无源汇可行流，只是忽略掉弧就好。 而且这时候弧的流量就是原图的总流量。 理解方法： 有源汇相比无源汇的不同就在于，源和汇是不满足流量平衡的，那么连接之后，源和汇也满足了流量平衡，就可以直接按照无源汇的方式建模。 注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。有源汇最大流 建模方法： 首先按照有源汇可行流的方法建模，如果不存在可行流，更别提什么最大流了。 如果存在可行流，那么在运行过有源汇可行流的图上（就是已经存在流量的那张图，流量不要清零），跑一遍从s到t的最大流（这里的s和t是原图的源和汇，不是附加源和附加汇），就是原图的最大流。 理解方法： 为什么要在那个已经有了流量的图上跑最大流？因为那张图保证了每条弧的容量下界，在这张图上跑最大流，实际上就是在容量下界全部满足的前提下尽量多得获得“自由流量”。 注意，在这张已经存在流量的图上，弧也是存在流量的，千万不要忽略这条弧。因为它的相反弧的流量为的流量的相反数，且的容量为0，所以这部分的流量也是会被算上的。有源汇最小流 有源汇最小流的常见建模方法比较多，我就只说我常用的一种。 建模方法： 首先按照有源汇可行流的方法建模，但是不要建立这条弧。 然后在这个图上，跑从附加源ss到附加汇tt的最大流。 这时候再添加弧，下界为0，上界为∞。 在现在的这张图上，从ss到tt的最大流，就是原图的最小流。 理解方法： 我们前面提到过，有源汇可行流的流量只是对应一组可行流，并不是最大或者最小流。 并且在跑完有源汇可行流之后，弧的流量就是原图的流量。 从这个角度入手，我们想让弧的流量尽量小，就要尽量多的消耗掉那些“本来不需要经过”的流量。 于是我们在添加之前，跑一遍从ss到tt的最大流，就能尽量多的消耗那些流量啦QwQ。总结 口胡完毕。 我姿势水平不高，没见过什么上下界网络流的题（或许真的不常考？），唯一见过的一道就放上来叭QwQ。题目与题解 Inspection LA 4597 NEERC 2009 题解还请看我的博客QwQ：http://www.cnblogs.com/mlystdcall/p/6734979.html]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3338烦的一比网络流]]></title>
    <url>%2Funcategorized%2FHDU-3338%E7%83%A6%E7%9A%84%E4%B8%80%E6%AF%94%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[本来想着要区域赛 就暂时不写题解了。忍不住了，这题踩了太多坑了，状态也不太好，比起做的时间，写题解的时间怎么也不算多。 放两张图片 方便自己看 本质是一个方格填数的题就这么几个格子黑色 不能放值。但他本身可有值左值代表这个点向下直到下个黑点或者边界中的一列白格填的总数为这个左值右值同理这个点向右直到下个黑点或者边界中的一行白格填的总数为这个左值 白色 被填的格子，其他用 这里建图真的是鬼斧神工，根本想不到。首先按行相加的值和按列相加的值肯定是一致的。这里的处理很巧妙从每行到每列建边大概就是这么个意思，自己看的懂就行了。源点连所有的黑点的左半部分（如果有值的话）汇点连所有的黑点的右半部分（如果有值的话） 那么白点怎么处理? 连他左边第一个黑点（有值）和上面第一个黑点（有值），注意拆点，这里就不赘述了。 至于为什么？ 你猜。 tm的200多行，输入有点恶心了。ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAXN = 21000;//点数的最大值const int MAXM = 1e7+10;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear) &#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; int inser; for(int i = 0; i &lt; top; i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow) &#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0; i &lt; top; i++) &#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125;int G[110][110][2];//0--下 1--右char tmp[10];int shift(int x)&#123; int s,e; if(x==1) s=0,e=2; else s=4,e=6; int ans=0; for(int i=s;i&lt;=e;i++)&#123; ans=ans*10+tmp[i]-'0'; &#125; return ans;&#125;int n,m;int right(int x,int y)&#123; int i=1; while(y+i&lt;=m &amp;&amp; G[x][y+i][0]==-2)&#123; i++; &#125; return i-1;&#125;int down(int x,int y)&#123; int i=1; while(x+i&lt;=n&amp;&amp;G[x+i][y][0]==-2)&#123; i++; &#125; return i-1;&#125;//int G[MAXN][MAXN][2];//0--下 1--右int upb(int x,int y)&#123; //1 int i=-1; while(x+i&gt;0&amp;&amp;G[x+i][y][0]==-2)&#123; i--; &#125; return x+i;&#125;int leftb(int x,int y)&#123; //0 int i=-1; while(y+i&gt;0&amp;&amp;G[x][y+i][0]==-2)&#123; i--; &#125; return y+i;&#125;void show()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++) cout&lt;&lt;G[i][j][0]&lt;&lt;" "&lt;&lt;G[i][j][1]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;//int G[MAXN][MAXN][2];//0--下 1--右int eee(int x,int y)&#123; int pos=(x-1)*m+y; for(int u=head[pos];~u;u=edge[u].next)&#123; return edge[u].flow; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; scanf("%s",tmp); if(tmp[0]=='.') G[i][j][0]=G[i][j][1]=-2; else &#123; if(tmp[0]=='X') G[i][j][0]=-1; else &#123; G[i][j][0]=shift(1); &#125; if(tmp[4]=='X') G[i][j][1]=-1; else G[i][j][1]=shift(0); &#125; &#125; &#125;//先处理权值//源点//汇点 int s=0,e=2*n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]&gt;0)&#123;//是个黑点 G[i][j][0]-=down(i,j); //cout&lt;&lt;G[i][j][0]&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; addedge(n*m+(i-1)*m+j,e,G[i][j][0]); &#125; if(G[i][j][1]&gt;0)&#123;//是个黑点 G[i][j][1]-=right(i,j); //cout&lt;&lt;G[i][j][1]&lt;&lt;" "&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; addedge(s,(i-1)*m+j,G[i][j][1]); &#125; &#125;//对白点加边 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]==-2)&#123; int yy=leftb(i,j); int xx=upb(i,j); addedge((i-1)*m+yy,(i-1)*m+j,8); addedge((i-1)*m+j,n*m+(xx-1)*m+j,8); &#125; &#125; int flow=sap(s,e,e+1); for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(G[i][j][0]!=-2) printf("_%c"," \n"[j==m]); if(G[i][j][0]==-2)&#123; printf("%d%c",1+eee(i,j)," \n"[j==m]); &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流模板]]></title>
    <url>%2Funcategorized%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[最大流$O(n^2*\sqrt{v})$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115//isap#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;const int MAXN = 5010;//点数的最大值const int MAXM = 1e7+10;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;int Q[MAXN];void BFS(int start,int end)&#123; memset(dep,-1,sizeof(dep)); memset(gap,0,sizeof(gap)); gap[0] = 1; int front = 0, rear = 0; dep[end] = 0; Q[rear++] = end; while(front != rear) &#123; int u = Q[front++]; for(int i = head[u]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if(dep[v] != -1)continue; Q[rear++] = v; dep[v] = dep[u] + 1; gap[dep[v]]++; &#125; &#125;&#125;int S[MAXN];int sap(int start,int end,int N)&#123; BFS(start,end); memcpy(cur,head,sizeof(head)); int top = 0; int u = start; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; int inser; for(int i = 0; i &lt; top; i++) if(Min &gt; edge[S[i]].cap - edge[S[i]].flow) &#123; Min = edge[S[i]].cap - edge[S[i]].flow; inser = i; &#125; for(int i = 0; i &lt; top; i++) &#123; edge[S[i]].flow += Min; edge[S[i]^1].flow -= Min; &#125; ans += Min; top = inser; u = edge[S[top]^1].to; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = i; break; &#125; &#125; if(flag) &#123; S[top++] = cur[u]; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min + 1; gap[dep[u]]++; if(u != start)u = edge[S[--top]^1].to; &#125; return ans;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283const int MAXN = 100010;//点数的最大值const int MAXM = 400010;//边数的最大值const int INF = 0x3f3f3f3f;struct Edge&#123; int to,next,cap,flow;&#125; edge[MAXM]; //注意是MAXMint tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol = 0; memset(head,-1,sizeof(head));&#125;//加边,单向图三个参数,双向图四个参数void addedge(int u,int v,int w,int rw = 0)&#123; edge[tol] = Edge&#123;v,head[u],w,0&#125;; head[u] = tol++; edge[tol] =Edge&#123;u,head[v],rw,0&#125;; head[v] = tol++;&#125;//输入参数:起点、终点、点的总数//点的编号没有影响,只要输入点的总数int sap(int start,int end,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u = start; pre[u] = -1; gap[0] = N; int ans = 0; while(dep[start] &lt; N) &#123; if(u == end) &#123; int Min = INF; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) if(Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; for(int i = pre[u]; i != -1; i = pre[edge[i^1].to]) &#123; edge[i].flow += Min; edge[i^1].flow -= Min; &#125; u = start; ans += Min; continue; &#125; bool flag = false; int v; for(int i = cur[u]; i != -1; i = edge[i].next) &#123; v = edge[i].to; if(edge[i].cap - edge[i].flow &amp;&amp; dep[v]+1 == dep[u]) &#123; flag = true; cur[u] = pre[v] = i; break; &#125; &#125; if(flag) &#123; u = v; continue; &#125; int Min = N; for(int i = head[u]; i != -1; i = edge[i].next) if(edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123; Min = dep[edge[i].to]; cur[u] = i; &#125; gap[dep[u]]--; if(!gap[dep[u]])return ans; dep[u] = Min+1; gap[dep[u]]++; if(u != start) u = edge[pre[u]^1].to; &#125; return ans;&#125; 邻接矩阵，可以跑多次，不用拆图，写起来简单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int MAXN=110;int maze[MAXN][MAXN];int gap[MAXN],dis[MAXN],pre[MAXN],cur[MAXN];int flow[MAXN][MAXN];//存最大流的容量int sap(int start,int end,int nodenum)&#123; memset(cur,0,sizeof(cur)); memset(dis,0,sizeof(dis)); memset(gap,0,sizeof(gap)); memset(flow,0,sizeof(flow)); int u=pre[start]=start,maxflow=0,aug=-1; gap[0]=nodenum; while(dis[start]&lt;nodenum) &#123; loop: for(int v=cur[u]; v&lt;nodenum; v++) if(maze[u][v]-flow[u][v] &amp;&amp; dis[u]==dis[v]+1) &#123; if(aug==-1 || aug&gt;maze[u][v]-flow[u][v])aug=maze[u][v]-flow[u][v]; pre[v]=u; u=cur[u]=v; if(v==end) &#123; maxflow+=aug; for(u=pre[u]; v!=start; v=u,u=pre[u]) &#123; flow[u][v]+=aug; flow[v][u]-=aug; &#125; aug=-1; &#125; goto loop; &#125; int mindis=nodenum-1; for(int v=0; v&lt;nodenum; v++) if(maze[u][v]-flow[u][v]&amp;&amp;mindis&gt;dis[v]) &#123; cur[u]=v; mindis=dis[v]; &#125; if((--gap[dis[u]])==0)break; gap[dis[u]=mindis+1]++; u=pre[u]; &#125; return maxflow;&#125; 最小费用最大流 玄学复杂度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN = 1000;typedef long long LL;typedef pair&lt;int,int&gt; PII;const int MAXM = 100000;const int INF = 0x3f3f3f3f;struct Edge&#123; int to, next, cap, flow, cost;&#125; edge[MAXM];int head[MAXN], tol;int pre[MAXN], dis[MAXN];bool vis[MAXN];int N; //0~N-1的点数void init(int n)&#123; N = n; tol = 0; memset(head, -1, sizeof(head));&#125;void addedge(int u, int v, int cap, int cost)&#123; edge[tol] = Edge&#123;v,head[u],cap,0,cost&#125;; head[u] = tol++; edge[tol] = Edge&#123;u,head[v],0,0,-cost&#125;; head[v] = tol++;&#125;bool spfa(int s, int t)&#123; queue&lt;int&gt; q; for (int i = 0; i &lt; N; i++)&#123; dis[i] = INF; vis[i] = false; pre[i] = -1; &#125; dis[s] = 0; vis[s] = true; q.push(s); while (!q.empty())&#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; i != -1; i = edge[i].next)&#123; int v = edge[i].to; if (edge[i].cap &gt; edge[i].flow &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost)&#123; dis[v] = dis[u] + edge[i].cost; pre[v] = i; if (!vis[v])&#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; if (pre[t] == -1) return false; else return true;&#125;int minCostMaxflow(int s, int t, int &amp;cost)&#123; int flow = 0; cost = 0; while (spfa(s, t))&#123; int Min = INF; for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])&#123; if (Min &gt; edge[i].cap - edge[i].flow) Min = edge[i].cap - edge[i].flow; &#125; for (int i = pre[t]; i != -1; i = pre[edge[i ^ 1].to])&#123; edge[i].flow += Min; edge[i ^ 1].flow -= Min; cost += edge[i].cost * Min; &#125; flow += Min; &#125; return flow;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 6386]]></title>
    <url>%2Funcategorized%2FHDU-6386%2F</url>
    <content type="text"><![CDATA[dij最短路 + 条件限制这道题很有意思，加深了我对Dij的理解。题意很简单，找一条从1到n的最短路，但若是前一条路和后一条路一致，那么就不计算后一条路，不然不一样了就+1,即边权全是1或0，是0是1取决于前一权值是否和当前权值一致。那么关键点在哪里呢？对于dij堆优化的理解。首先，优先队列里存放的到底是什么？是待选答案。vis数组起到什么作用？区分处理完的集合，和待处理数据的集合。那么优先队列起到的是取出待处理数据中离处理完集合 距离最小的那个。 这看似是非常基础的dij最短路的知识，但在这道题中是一个关键点。 平常dij都有这段1234if(!vis[v]&amp;&amp;dis[v] &gt; w+dis[u])&#123; dis[v] = w+dis[u]; q.push(qnode&#123; v,dis[v]&#125;);&#125; 这里是用以处理好的点的最短路去不停的更新未访问结点的最短路，直到访问过的点的最短路比一个未访问点的最短路长了，那么那个点就一定是到源点的最短路径了（比它短的都更新过它了） 所以存一下边，dij就可以了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=100010;const int M=400010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];struct qnode&#123; int id; int pre; int dis; bool operator &lt;(const qnode &amp;r)const &#123; return dis&gt;r.dis; &#125;&#125;;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,-1,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to,w=edge[i].val; if(!vis[v]&amp;&amp;dis[v]&gt;=dis[u]+(w!=cur.pre))&#123; dis[v]=dis[u]+(w!=cur.pre); q.push(qnode&#123;v,w,(w!=cur.pre) + dis[u]&#125;); &#125; &#125; &#125;&#125;int main() &#123; while(~scanf("%d%d", &amp;n, &amp;m)) &#123; init(); int u, v, w; for(int i=1; i&lt;=m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; Dij(1); if(dis[n] == INF) printf("-1\n"); else printf("%d\n", dis[n]); &#125; return 0;&#125;/*6 61 2 23 6 21 4 34 6 33 6 25 6 2*//*6 61 2 23 6 21 4 34 6 33 6 25 6 2*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图连通性模板]]></title>
    <url>%2Funcategorized%2F%E5%9B%BE%E8%BF%9E%E9%80%9A%E6%80%A7%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[有向图强连通缩点所需数组 $idx,low[MAXN],dfn[MAXN]$——————时间戳和两个访问标志$sccno ,scc[MAXN]$ ————点属于哪个连通分支，及连通分量数量$stack st ,inst[MAXN]$————栈，一个中间工具，用于分辨点属于哪个连通分量$vector G[MAXN];$————图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N = 40000;const int M = 500000;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int idx,low[N],dfn[N];int sccno,scc[N];stack&lt;int&gt;st; int inst[N];void tarjan_init()&#123; init(); clr(dfn,0); clr(inst,0); clr(scc,0); sccno=idx=0; while(!st.empty()) st.pop();&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++idx; st.push(x); inst[x]=1; for(int i=head[x];~i;i=edge[i].next) &#123; int v=edge[i].to; if(!dfn[v])&#123; tarjan(v); low[x]=min(low[v],low[x]); &#125; else if(inst[v])&#123; low[x]=min(low[x],dfn[v]); &#125; &#125; if(low[x]==dfn[x])&#123; ++sccno; int v; while(1)&#123; v=st.top(); st.pop(); inst[v]=0; scc[v] = sccno; if(x==v) break; &#125; &#125;&#125; 割边&amp;&amp;割点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//割点const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; for (int i=1;i&lt;=n;i++) head[i]=-1;&#125;int low[N],dfn[N],idx;int iscut[N];int rootson;void tarjan_init()&#123; init(); clr(dfn,0); idx=rootson=0; clr(iscut,0);&#125;void tarjan(int u,int pre,int id)&#123; dfn[u]=low[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; if(!dfn[v])&#123; tarjan(v,u,i); if(u==1) rootson++; else &#123; low[u]=min(low[u],low[v]); if(low[v]&gt;=dfn[u]) iscut[u]=1; &#125; &#125;else&#123; low[u]= min(low[u],dfn[v]); &#125; &#125;&#125;if(rootson&gt;1) iscut[1]=1;//调用后 加一句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//割边const int N = 40000;const int M = 500000;int n,m;int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int low[N],dfn[N],idx;int fa[N],isbridge[N];int bridge;void tarjan_init()&#123; init(); clr(dfn,0); bridge=idx=0; clr(isbridge,0); clr(fa,0);&#125;void tarjan(int u,int pre,int id)&#123; fa[u]=pre; low[u]=dfn[u]=++idx; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; if(i==(id^1)) continue; //...... if(!dfn[v])&#123; tarjan(v,u,i); low[u]=min(low[u],low[v]); if(low[v] &gt; dfn[u]) &#123; isbridge[v]=1,bridge++; //cout&lt;&lt;"isbridge"&lt;&lt;endl; &#125; &#125; else if(v!=pre)&#123; //。。。。。 low[u]=min(low[u],dfn[v]); &#125; &#125;&#125;//注意isbridge数组与fa数组一起用，且若isbridge[i]，则i和fa[i]是割边//重边要不要注意写法 割边割点注意=号]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>连通性</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论前向星板子]]></title>
    <url>%2Funcategorized%2F%E5%9B%BE%E8%AE%BA%E5%89%8D%E5%90%91%E6%98%9F%E6%9D%BF%E5%AD%90%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122int head[N];int top;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top]=Edge&#123;c,b,head[a]&#125;; head[a]=top++;&#125;void init()&#123; top=0; memset(head,-1,sizeof(head));&#125;//遍历方式for(int i=head[u];~i;i=edge[i].next)]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路图论模板]]></title>
    <url>%2Funcategorized%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%9B%BE%E8%AE%BA%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[最短路图论模板 单源最短路dij$O((E+N)logN)$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int N=3000;const int M=71000;int n,m;int dis[N];int vis[N];struct edge&#123; int to,v;&#125;;struct qnode&#123; int id; int v; bool operator &lt;(const qnode &amp;r)const &#123; return v&gt;r.v; &#125;&#125;;vector&lt;edge&gt; G[N];void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to,w=G[u][i].v; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(qnode&#123;v,dis[v]&#125;); &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//前向星模板 防止类似poj老oj卡vector 一般不用const int N=40010;const int M=150010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];struct qnode&#123; int id; int dis; bool operator &lt;(const qnode &amp;r)const &#123; return dis&gt;r.dis; &#125;&#125;;void Dij(int start)&#123; clr(vis,0); clr(dis,INF); priority_queue&lt;qnode&gt; q; dis[start] = 0; q.push(qnode&#123;start,0&#125;); while(!q.empty())&#123; qnode cur=q.top(); q.pop(); int u=cur.id; if(vis[u]) continue; vis[u]=1; for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to,w=edge[i].val; if(!vis[v]&amp;&amp;dis[v] &gt; w+dis[u])&#123; dis[v] = w+dis[u]; q.push(qnode&#123; v,dis[v]&#125;); &#125; &#125; &#125;&#125; spfa$O(km)$ k最坏情况下是n 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N=10010;const int M=500010;int n,m;int dis[N];struct edge&#123; int to;int v;&#125;;vector&lt;edge&gt; G[N];int vis[N];int cnt[N];//每个点的入队次数void init()&#123; for(int i=0;i&lt;=n;i++) G[i].clear();&#125;void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int cost=G[u][i].v; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859前向星const int N=50010;const int M=50010;int head[N];int top;int n,m;struct Edge&#123; int val; int to; int next;&#125;edge[M];void addedge(int a,int b,int c)&#123; edge[top].to=b; edge[top].val=c; edge[top].next=head[a]; head[a]=top++;&#125;void init()&#123; top=0; clr(head,-1);&#125;int dis[N];int vis[N];int cnt[N];//每个点的入队次数int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=head[u];~i;i=edge[i].next)&#123; int v=edge[i].to; int cost=edge[i].val; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125; 12345678//读入优化 哎 pojinline LL read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')f=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123;x=x*10+ch-'0';ch=getchar();&#125; return x*f;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-1201（差分约束入门）]]></title>
    <url>%2Funcategorized%2FPOJ-1201%EF%BC%88%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%85%A5%E9%97%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[返回专题https://blog.csdn.net/wyxxzsy/article/details/82776590废话不说，直接建模套板子x[i] 代表 0～i 里点的个数对于若干个x[i],有若干个约束条件如样例：53 7 38 10 36 8 11 3 110 11 1 第一个约束条件“3 7 3”就是x[7]-x[2]&gt;=3最终要求 x[最大]-x[最小-1]的最小值转换成最长路 模型2优化.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_i - a_j&gt;=c\Longrightarrow a_j - a_i&lt;=-c$，从点i到点j建立一条边(-c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。https://blog.csdn.net/wyxxzsy/article/details/82776590 除了明说的限制，还有隐含的条件$0&lt;= a_i-a_{i-1}&lt;=1$从i～（i-1）加-c的边 就ok了（被什么超级源点搞了半天，狗屎）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=50010;const int M=500010;int n,m;int dis[N];struct edge&#123; int to;int v;&#125;;vector&lt;edge&gt; G[N];int vis[N];int cnt[N];//每个点的入队次数void init()&#123; for(int i=0;i&lt;=N;i++) G[i].clear();&#125;void addedge(int u,int v,int w)&#123; G[u].push_back(edge&#123;v,w&#125;);&#125;int spfa(int start)&#123; clr(vis,0); clr(dis,INF); queue&lt;int&gt; q; dis[start] = 0; //vis[start] = 1; clr(cnt,0); cnt[start] = 1; q.push(start); while(!q.empty()) &#123; int u=q.front(); q.pop(); vis[u]=0; //不在队列里了 for(int i=0;i&lt;G[u].size();i++)&#123; int v=G[u][i].to; int cost=G[u][i].v; if(dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; if(!vis[v])&#123; vis[v] = 1; q.push(v); if(++cnt[v]&gt;n) return 0; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf("%d",&amp;m); int s=INF,e=0; init(); while(m--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); a++,b++; s=min(a,s); e=max(e,b); addedge(a-1,b,-c); &#125; for(int i=s;i&lt;=e;i++)&#123; addedge(i-1,i,0); addedge(i,i-1,1); &#125; n = e-s+10; spfa(s-1); printf("%d\n",-dis[e]); return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束入门+总结]]></title>
    <url>%2Funcategorized%2F%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E5%85%A5%E9%97%A8-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[差分约束入门+总结 给定一串序列，长度为n。$a_1,a_2,a_3……a_n$并给定m的限制条件，条件的格式为$a_i-a_j&lt;=c$求$a_n-a_1$的最大值考虑序列三个数a，b，c$a-b&lt;=v_1$$b-c&lt;=v_2$$a-c&lt;=v_3$$\Longrightarrow a-c&lt;=min(v_3,(v_1+v_2))$这个缩小约束条件的过程就是求最短路的过程所以可以用最短路模型来解决 模型1.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&lt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最大可能差值？方法：对于每个限制条件$a_i - a_j&lt;=c$，从点j到点i建立一条边(c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。 推广 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？就是反一反$a-b&gt;=v_1$$b-c&gt;=v_2$$a-c&gt;=v_3$$\Longrightarrow a-c&gt;=max(v_3,(v_1+v_2))$要满足所有条件，（a-c的）范围扩大，求最长路 模型2.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_i - a_j&gt;=c$，从点j到点i建立一条边(c)，求$a_{k2}$ 到 $a_{k1}$ 的最长路即可。 条件转换：$a-b&lt;=c \Longrightarrow b-a&gt;=c$$a-b=c \Longrightarrow a-b&lt;=c , b-a&lt;=c$….(简单数学变换) 模型2也可转换为模型1$a-b&gt;=v_1$ ``_````$b-a&lt;=-v_1$$b-c&gt;=v_2 \Longrightarrow$ $c-b&lt;=-v_2$$a-c&gt;=v_3$ ```````$c-a&lt;=-v_3$求$a_{k2}$ 到 $a_{k1}$ 的最短路模型2优化.给定一串序列 $a_1 - a_n$ 并给出若干限制条件$a_i - a_j&gt;=c$，要求 $a_{k1}$ 与 $a_{k2}$ 的最小可能差值？方法：对于每个限制条件$a_j - a_i&lt;=-c$，从点i到点j建立一条边(-c)，求$a_{k1}$ 到 $a_{k2}$ 的最短路即可。 对于一个求最短路（最长路）约束条件有可能有三种情况：1.有上界，即有解2.无解（有负环）3.任意多的解（约束条件不够强，或者说图不强连通） 有解就是最短路无解就是有负环，最短路负无穷大无穷解就是不连通，最短路正无穷大 题目集： 最长路（模板题）https://blog.csdn.net/wyxxzsy/article/details/82777158再提一句，超级源点，一开始对于网上加入超级源点，直接计算最短路很不理解，因为加入超级源点之后，源点到每个点的距离至多是0,所以我一度认为，加入超级源点只是为了图的连通性，判断负环而已。但在最长路模型里不一样，它的权值都是负的，正确的权值是-dis[v],0到反而是最小值（加负号后）了，不会影响答案，有意思。]]></content>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj 1821 Fence (dp+单调队列优化)]]></title>
    <url>%2Funcategorized%2Fpoj-1821-Fence-dp-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[给n个篱笆，k个工人接着给k行，分别描述工人的 负责区域大小 涂一个篱笆的收益 他所站的位置解释一下，一个工人如果涂篱笆了，一定是从他所站的位置出发的，即他负责的区域必须包括自己当前位置求最大的总收益dp[i][j] : 前i个工人 负责前j个篱笆的的最大收益 dp[i][j]=max(dp[i][j-1], dp[i-1][j-1], max(dp[i-1][k]+cost[i]*(j-k)) ) 详细解释一下 dp[i-1][k]+cost[i]*(j-k)前i-1个人负责前k个，剩下（j-k）个篱笆全由第i个人负责。j-len&lt;=k&lt;=pos-1有两个条件：1.第i个人要能负责到第k+1个2.j要大于等于其pos 程序分成两个部分：维护优先队列的部分，计算答案的部分 优先队列里维护什么值维护 dp[i-1][j]-cost[i]*j 的最大值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;struct node&#123; int len,pos,cost; bool operator &lt;(const node&amp; a)const &#123; return pos&lt;a.pos; &#125;&#125;a[110];int dp[110][16050];int q[16050];int main()&#123; int n,k; while(~scanf("%d%d",&amp;n,&amp;k))&#123; for(int i=1;i&lt;=k;i++) scanf("%d%d%d",&amp;a[i].len,&amp;a[i].cost,&amp;a[i].pos); sort(a+1,a+k+1); clr(dp,0); for(int i=1;i&lt;=k;i++) &#123; int h=0,t=0; q[t++] = max(0,a[i].pos-a[i].len);//找起点 for(int j=1;j&lt;=n;j++) &#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1]); if(j&gt;=a[i].pos+a[i].len) continue; while(h&lt;t &amp;&amp;q[h]+a[i].len &lt; j) h++;//不合法 if(j&lt;a[i].pos)&#123; int tmp=dp[i-1][j]-j*a[i].cost; while(h&lt;t &amp;&amp; dp[i-1][q[t-1]]-q[t-1]*a[i].cost &lt; tmp) t--; q[t++] = j; &#125; else&#123; dp[i][j] = max(dp[i][j],dp[i-1][q[h]]+a[i].cost*(j-q[h])); &#125;//这里不能入栈 k&lt;=pos-1 //cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;dp[i][j]&lt;&lt;endl; //cout&lt;&lt;h&lt;&lt;" "&lt;&lt;t&lt;&lt;endl&lt;&lt;endl; &#125; &#125; printf("%d\n",dp[k][n]); &#125; return 0;&#125;/*8 43 2 23 2 33 3 51 1 7*/ *tip：取队列尾部元素的时候要减1]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3530 单调队列入门]]></title>
    <url>%2Funcategorized%2FHDU-3530-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[伪入门 滑动窗口两个队列： 单调递减 维护最大值 单调递增 维护最小值 假设目前在处理第i个元素的入队列情况，首先，这个元素肯定是要入队列的，只是直接放在队列尾部和替换掉尾部一些元素的区别。eg. 1 3 2 5 4 两个队列的情况分别为 两个队列 1 3 2 5 4 维护最大值（递减序列） 1 3 3-2 5 5-4 维护最小值（递增序列） 1 1-3 1-2 1-2-5 1-2-4 这个队列有什么用？以5为例子， 3-2 3是到5为止最大的值,2是抛弃掉3之后到5为止最大的值 1-2 1是到5为止最小的值,2是抛弃掉1之后到5为止最小的值 所以不难理解他们的递减性和递增性 所以队列里面存的是什么？是最大值（最小值） 更详细地来说，队列头存放着可行范围的最大值，接着是 范围离开了队列头的位置后 产生的新最大值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int N=1e5+10;int q_max[N],q_min[N];//max维护最大值 递减int a[N];int n,m,k;//m&lt;= val &lt;=kint main()&#123; while(~scanf("%d%d%d",&amp;n,&amp;m,&amp;k))&#123; int tmp=0,ans=0; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int h1=0,t1=0,h2=0,t2=0; for(int i=1;i&lt;=n;i++)&#123; //真正的值是尾部-1 while(h1&lt;t1 &amp;&amp; a[q_max[t1-1]] &lt; a[i]) //相同值留在里面 t1--; while(h2&lt;t2 &amp;&amp; a[q_min[t2-1]] &gt; a[i]) t2--; q_max[t1++]=q_min[t2++]=i; //找到要抛弃的最值（最大或最小值，因为改变一个就改变了他们的差值） //也可能不抛弃任何一个，tmp值不变。 while(h1&lt;t1&amp;&amp;h2&lt;t2 &amp;&amp; a[q_max[h1]]-a[q_min[h2]]&gt;k) //找哪个最值在前面,决定不要哪个 if(q_max[h1]&lt;q_min[h2]) tmp=q_max[h1++]; else tmp=q_min[h2++]; if(h1&lt;t1&amp;&amp;h2&lt;t2 &amp;&amp; a[q_max[h1]]-a[q_min[h2]] &gt;= m) ans=max(ans,i-tmp); &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1693 插头dp]]></title>
    <url>%2Funcategorized%2FHDU-1693-%E6%8F%92%E5%A4%B4dp%2F</url>
    <content type="text"><![CDATA[什么是插头dp？首先我们要先知道它能解决那些问题。一般都是一张方格图里有关连通性的一些问题。那么对于一个格子而言，他就可能会有一些线经过它。（所以也可以没有，看题目）例如这张图那么插头就是描述这些线条如何穿过这些格子 那如何用插头来表示一种状态？对于一个宽度为m的图，它的插头就有m+1种，每一种插头的01状态代表这个位置有没有插头。 那么状态如何转移呢？就这么几种状态，可以分类讨论或者适当简化一下。 一行之尾与下一行之首间的转化 初始化的时候就是-1行state为0时才为1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;int G[15][15];LL dp[2][(1&lt;&lt;12)+10];int n,m;int main()&#123; int t;scanf("%d",&amp;t); int cas=0; while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) scanf("%d",&amp;G[i][j]); int total=1&lt;&lt;(m+1); //初始化 clr(dp,0); //至于其他初值取决于行之间的转移 dp[1][0]=1; int cur=1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123;//对 int plug1=(1&lt;&lt;j),plug2=(1&lt;&lt;(j+1)); cur^=1; clr(dp[cur],0); for(int st=0; st&lt;total; st++)&#123; if(G[i][j])&#123; dp[cur][st^plug1^plug2] += dp[cur^1][st]; if(((plug1&amp;st)==0)^((plug2&amp;st)==0)) dp[cur][st]+=dp[cur^1][st]; &#125; else &#123; if((plug1&amp;st)||(plug2&amp;st)) dp[cur][st]=0; else dp[cur][st] += dp[cur^1][st]; &#125; &#125; &#125; cur^=1; clr(dp[cur],0); for(int st=0;st&lt;(1&lt;&lt;m);st++) dp[cur][(st&lt;&lt;1)] += dp[cur^1][st]; &#125; printf("Case %d: There are %lld ways to eat the trees.\n",++cas,dp[cur][0]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>插头dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮廓线dp入门题 && POJ - 2411]]></title>
    <url>%2Funcategorized%2F%E8%BD%AE%E5%BB%93%E7%BA%BFdp%E5%85%A5%E9%97%A8%E9%A2%98-POJ-2411%2F</url>
    <content type="text"><![CDATA[题目很有意思，就是oj太烂了刘汝佳的代码太优雅了，看不懂，但意思差不多。就我做过的状压dp总是以一行（或一列）为一个状态，先理清一行中的关系，后再找行对行的关系这里不能用行，行之间的关系不够了，因为要考虑不同的放法。那一行不够，两行够不够？我觉得够，但时间复杂度不够优秀，会包含很多无效转态所以优化一下？ dp三个问题：1.状态的确立2.状态转移方程3.初始化 1.dp[i][j][state] : 右下角位置是（i，j），状态是state的总数因为只要求dp[n-1][m-1][$2^m-1$]的值滚动数组 为 dp[2][state]当前状态只于之前有关2.转移方程:若dp[cur][state]合理，那么转移到另一个合理状态。如何转移1.（上）考虑当前放竖着的块。前提:上方的状态为0（没放）并且 现在不是第一行dp[cur][可以到的状态]+=dp[1^cur][state]2.（不放）考虑当前没有以（i，j）为右下角的块前提:上方是1，（上方不能为0吧）dp[cur][可以到的状态]+=dp[1^cur][state]3.（左）。。。。差不多123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define clr(a, x) memset(a, x, sizeof(a))typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF=0x3f3f3f3f;int n,m,cur;const int N =15;LL dp[2][1&lt;&lt;N];int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n+m))&#123; if(n&lt;m) swap(n,m); clr(dp,0); cur=0; dp[0][(1&lt;&lt;m)-1]=1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cur^=1; clr(dp[cur],0); for(int s=0;s&lt;(1&lt;&lt;m);s++)&#123; if(dp[1-cur][s]==0) continue; //上方 if(i!=0 &amp;&amp; (s&amp;(1&lt;&lt;(m-1)))==0) //非首行且上方是0 现在可以放竖着的块 &#123; int now = ((s&lt;&lt;1)|1) &amp; ((1&lt;&lt;m)-1); dp[cur][now] += dp[1-cur][s]; &#125; //左方 if( j!=0 &amp;&amp; (s &amp;(1&lt;&lt;(m-1))) &amp;&amp; (s&amp;1)==0 ) &#123; int now=((s&lt;&lt;1)|3)&amp;((1&lt;&lt;m)-1); dp[cur][now]+=dp[1-cur][s]; &#125; //不放 if(s &amp;(1&lt;&lt;(m-1)))&#123; int now=((s&lt;&lt;1)&amp;((1&lt;&lt;m)-1)); dp[cur][now]+=dp[1-cur][s]; &#125; &#125; &#125; printf("%lld\n",dp[cur][(1&lt;&lt;m)-1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
        <tag>轮廓线dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces - 11D]]></title>
    <url>%2Funcategorized%2FCodeForces-11D%2F</url>
    <content type="text"><![CDATA[有意思 和之前的项链异曲同工，但之前就是入门，半抄半做的。one more time 再跑一遍吧环？怎么处理环？都是通过记录路径，若是首末可相连，那么就是个环，同时，这样也可以用作之后的状态转移，妙啊dp[i][s]: 路径的最后一个点是i且状态是s，且有隐含条件开头是是状态的第一个1。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define legal(a,b) a&amp;btypedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int G[21][21];LL dp[21][1&lt;&lt;20];//dp[i][state] 以第一个1出现的位置作为开头，以i结尾的路径的数量int num[1&lt;&lt;21];int n,m;//dp[i][s|(1&lt;&lt;i)] += dp[e][s]int solve(int state)&#123; int ans=0; for(int i=0; i&lt;=20; i++) if(state &amp;(1&lt;&lt;i)) ans++; return ans;&#125;int main()&#123; for(int i=0; i&lt;(1&lt;&lt;21); i++) num[i] = solve(i); while(cin&gt;&gt;n&gt;&gt;m) &#123; clr(G,0); for(int i=0,x,y; i&lt;m; i++) &#123; cin&gt;&gt;x&gt;&gt;y; x--; y--; G[x][y]=G[y][x]=1; &#125; clr(dp,0); //初始化 for(int i=0; i&lt;n; i++) dp[i][1&lt;&lt;i] = 1; int total=1&lt;&lt;n; LL ans=0; for(int s=1; s&lt;total; s++) &#123; //找开头 int st=0; for(int i=0; i&lt;n; i++) if(s&amp;(1&lt;&lt;i)) st=i,i=n; for(int i=st; i&lt;n; i++) //枚举状态中的结尾 if(s&amp;(1&lt;&lt;i)&amp;&amp;(dp[i][s])) for(int j=st; j&lt;n; j++) //枚举新状态的结尾 &#123; if(s&amp;(1&lt;&lt;j)) continue; if(G[i][j]==0) continue; dp[j][s|(1&lt;&lt;j)] += dp[i][s]; if(G[st][j] &amp;&amp; num[s|(1&lt;&lt;j)]&gt;=3) ans+=dp[i][s]; &#125; &#125; cout&lt;&lt;ans/2&lt;&lt;endl; &#125; return 0;&#125;/*4 61 21 31 42 32 43 4*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 4539]]></title>
    <url>%2Funcategorized%2FHDU-4539%2F</url>
    <content type="text"><![CDATA[纯状压题，dp部分很简单考虑一行上的限制条件，再去深究列上的限制123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int state[1&lt;&lt;10];int soldier[1&lt;&lt;10];int G[110];LL dp[110][180][180];int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; clr(G,0); clr(dp,0); clr(soldier,0); clr(state,0); for(int i=0;i&lt;n;i++) for(int j=0,x;j&lt;m;j++) &#123; cin&gt;&gt;x; if(!x) G[i]|=1&lt;&lt;j; &#125; int num=0; for(int i=0;i&lt;(1&lt;&lt;m);i++) &#123; if(i &amp; (i&lt;&lt;2)) continue; for(int j=0;j&lt;m;j++) if(i &amp; (1&lt;&lt;j)) soldier[num]++; state[num++] = i; &#125; LL ans=0; for(int i=0;i&lt;num;i++) &#123; if(G[0]&amp;state[i]) continue; dp[0][i][0] = soldier[i]; ans=max(ans,1LL*soldier[i]); &#125; if(n==1)&#123; cout&lt;&lt;ans&lt;&lt;endl; continue; &#125; for(int i=0;i&lt;num;i++) &#123; if(G[1]&amp;state[i]) continue; for(int j=0;j&lt;num;j++) &#123; if(G[0]&amp;state[j]) continue; if((state[j]&lt;&lt;1)&amp;state[i]) continue; if((state[i]&lt;&lt;1)&amp;state[j]) continue; dp[1][i][j] = max(dp[1][i][j],dp[0][j][0]+soldier[i]); ans=max(ans,dp[1][i][j]); &#125; &#125; for(int r=2;r&lt;n;r++) &#123; for(int i=0;i&lt;num;i++) &#123; if(state[i]&amp;G[r]) continue; for(int j=0;j&lt;num;j++) &#123; if(G[r-1]&amp;state[j]) continue; if((state[j]&lt;&lt;1)&amp;state[i]) continue; if((state[i]&lt;&lt;1)&amp;state[j]) continue; for(int k=0;k&lt;num;k++) &#123; if(G[r-2]&amp;state[k]) continue; if(state[k]&amp;state[i]) continue; if((state[k]&lt;&lt;1)&amp;state[j]) continue; if((state[k])&amp;(state[j]&lt;&lt;1)) continue; dp[r][i][j] = max(dp[r][i][j],dp[r-1][j][k]+soldier[i]); ans=max(ans,dp[r][i][j]); &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1565]]></title>
    <url>%2Funcategorized%2FHDU-1565%2F</url>
    <content type="text"><![CDATA[这道题以为是简单的模板题（确实简单啊。。。），卡了好久1.内存限制，之前题放的很开，这里要卡一下最多的状态数，但没卡滚动数组（也卡不了吧）2.注意要统计的是最值还是数量。3.二进制状态 $2^n 和2^{n+1}$ 是分开的 可以预处理$2^{20}$ 再对不同n取前缀，但效果不明显。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;LL G[30][30];LL state[20000];LL sum[20][20000];LL dp[20][20000];int n;LL dfs(int r,int id)&#123; if(sum[r][id]) return sum[r][id]; int ans=0; for(int i=0;i&lt;n;i++) &#123; if(state[id]&amp;(1&lt;&lt;i)) ans+=G[r][i]; &#125; return ans;&#125;int main()&#123; int num=0; for(int i=0;i&lt;(1&lt;&lt;20);i++) if(!(i&amp;(i&lt;&lt;1))) state[num++] = i; while(cin&gt;&gt;n)&#123; clr(sum,0); clr(dp,0); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%d",&amp;G[i][j]); int total=(1&lt;&lt;n); int id=0; for(;id&lt;num;id++) if(state[id]&gt;total) break; LL ans=0; for(int i=0;i&lt;id;i++) &#123; dp[0][i] = dfs(0,i); ans=max(ans,dp[0][i]); &#125; for(int r=0;r&lt;n-1;r++) for(int i=0;i&lt;id;i++) if(dp[r][i]) for(int j=0;j&lt;id;j++) &#123; if(state[i]&amp;state[j]) continue; dp[r+1][j] = max(dp[r][i] + dfs(r+1,j),dp[r+1][j]); ans=max(ans,dp[r+1][j]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 发现一个轮廓线dp做法 有意思初始值（初始值的选取也有讲究）|0|0|0|0|0||-|-| 需要更新的值|x|x|0|1|0||-||1|0|?|x|x|状态$n^2-1$就是形似上图所示的意义。对于一个$n×n$的矩阵，从行，列一一遍历，同时更新每个可到达的状态的最大值。其他和入门题一致，比较简单。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);#define clr(a, x) memset(a, x, sizeof(a))typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF=0x3f3f3f3f;int n,cur;LL G[25][25];LL dp[2][1&lt;&lt;20];int main()&#123; while(~scanf("%d",&amp;n))&#123; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%lld",&amp;G[i][j]); clr(dp,0); cur=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) &#123; cur=1^cur; clr(dp[cur],0); for(int st=0;st&lt;(1&lt;&lt;n);st++)&#123; //取 if( (j==0||(st&amp;1)==0) &amp;&amp; (st&amp;(1&lt;&lt;(n-1)))==0) //已经保证首位不是1 dp[cur][(st&lt;&lt;1)|1] = max(dp[cur][(st&lt;&lt;1)|1],dp[1^cur][st]+G[i][j]); //不取 dp[cur][(st&lt;&lt;1)&amp;(1&lt;&lt;n)-1] = max(dp[cur][(st&lt;&lt;1)&amp;(1&lt;&lt;n)-1],dp[1^cur][st]); &#125; &#125; LL ans=0; for(int i=0;i&lt;(1&lt;&lt;n);i++) ans=max(ans,dp[cur][i]); printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3091]]></title>
    <url>%2Funcategorized%2FHDU-3091%2F</url>
    <content type="text"><![CDATA[有一个DP题，意题都看了好久用n个珠子串成一个项链，但是n个珠子两两之间可能不能放在一起，问有几种串珠子的方式？因为项链可以旋转，所以选择一个起点最终走到这个起点，且每个点只能走一次，问有多少种情况？ 类似旅行商问题，但不一样。问题还是对于一个珠子之后，它要选哪个珠子，因为n个珠子都要被选到，这里解决的就是个顺序问题。如何定义dp状态dp[state][i] :在state状态下，且以i为最后一个放入的元素的情况下的总数。 转移方式：从这个状态可以转移到的状态，目标状态总数+=现在的状态总数(状态之间只有加法的时候，这种转移很有用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int n,m;int G[20][20];LL dp[20][1&lt;&lt;19];//dp[i][j] 最后放的是i，状态为j的个数int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; clr(G,0); clr(dp,0); for(int i=0,x,y;i&lt;m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; x--;y--; G[x][y]=G[y][x]=1; &#125; dp[0][1] = 1;//固定一开始放0 那转态就是1 for(int st=1;st&lt;(1&lt;&lt;n);st++) //枚举状态 for(int j=0;j&lt;n;j++)//拆解转态 &#123; if(dp[j][st]==0) continue; for(int k=1;k&lt;n;k++) //0已经加进去了 无需考虑 &#123; if( G[j][k] &amp;&amp; (st&amp;(1&lt;&lt;k))==0 ) dp[k][st|(1&lt;&lt;k)]+=dp[j][st]; &#125; &#125; LL sum=0; for(int i=0;i&lt;n;i++)&#123; //cout&lt;&lt;dp[i][(1&lt;&lt;n)-1]&lt;&lt;endl; if(G[i][0])&#123; sum+=dp[i][(1&lt;&lt;n)-1]; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;/*3 31 21 32 3*/]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 6435]]></title>
    <url>%2Funcategorized%2FHDU-6435%2F</url>
    <content type="text"><![CDATA[可惜了 这道题还是能做的首先这道题非常容易想到暴力做，但绝对不能暴力做，这一类的题型，我感觉要挖掘题面中的特有信息。比如: k&lt;=5,曼哈顿距离（去绝对值）当然都注意到了也没用，题做的少啊这一手状压还是很妙的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int N=1e5+10;const int INF=0x3f3f3f3f;LL a[1&lt;&lt;5];LL b[1&lt;&lt;5];LL state[10];int n,m,k;inline LL solve(int sta)&#123; LL ans=0; for(int i=0;i&lt;k;i++) if((1&lt;&lt;i)&amp;sta) ans+=state[i]; else ans-=state[i]; return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; clr(a,-INF); clr(b,-INF); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int total=1&lt;&lt;(k); for(int i=0,s;i&lt;n;i++) &#123; scanf("%d",&amp;s); for(int j=0;j&lt;k;j++) scanf("%lld",&amp;state[j]); for(int j=0;j&lt;total;j++)&#123; a[j] = max(a[j],s+solve(j)); //cout&lt;&lt;a[i][j]&lt;&lt;endl; &#125; &#125; for(int i=0,s;i&lt;m;i++) &#123; scanf("%d",&amp;s); for(int j=0;j&lt;k;j++) scanf("%lld",&amp;state[j]); for(int j=0;j&lt;total;j++) b[j] = max(b[j],s+solve(j)); &#125; //for(int i=0;i&lt;total;i++) cout&lt;&lt;b[i]&lt;&lt;endl; LL ans=0; for(int j=0;j&lt;total;j++)&#123; ans=max(ans,a[j]+b[total-j-1]); //cout&lt;&lt;j&lt;&lt;" "&lt;&lt;total-j-1&lt;&lt;endl; &#125;// cout&lt;&lt;ans&lt;&lt;endl; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 1074]]></title>
    <url>%2Funcategorized%2FHDU-1074%2F</url>
    <content type="text"><![CDATA[A - Doing Homework HDU - 1074入门题 很有意思最多十五门课 15位二进制0代表没选这门课 1代表选了这门课状态从 $ 0 $ ~$ (2^{n-1}) $即什么都没选到所有课对于一个state 我要知道这个状态时的罚时，就是从前一个能到达的转态中取使其罚时最小的状态转移过来，同时更新总时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;const int N=70000;string name[20];int deadline[20],length[20];int dp[1&lt;&lt;17]; //取这个状态要减多少分int t[1&lt;&lt;17];//到达这个转态的时间int pre[1&lt;&lt;17];void print_ans(int state)&#123; int j = pre[state]; if(state==0) return ; print_ans(state ^ (1&lt;&lt;j)); cout&lt;&lt;name[j]&lt;&lt;endl;&#125;int main()&#123; int cas;scanf("%d",&amp;cas); while(cas--)&#123; int n;scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) cin&gt;&gt;name[i]&gt;&gt;deadline[i]&gt;&gt;length[i]; for(int i=1;i&lt;(1&lt;&lt;n);i++) &#123; //对于状态i计算 dp[i] = INF; for(int j=n-1;j&gt;=0;j--) &#123; if(i&amp;(1&lt;&lt;j)) &#123; int now=i^(1&lt;&lt;j); //从now转移到i int reduce= t[now] + length[j] - deadline[j]; if(reduce&lt;0) reduce=0; if(dp[i] &gt; dp[now]+reduce)&#123; t[i] = t[now]+length[j]; dp[i] = dp[now]+reduce; pre[i] = j; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl; print_ans((1&lt;&lt;n)-1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU - 3182]]></title>
    <url>%2Funcategorized%2FHDU-3182%2F</url>
    <content type="text"><![CDATA[一眼看上去有点像变形背包，但完全不是每种汉堡只能选一种，选一种，且选i种汉堡 需要先作出规定的汉堡比较难的就是如何判断这个状态是合法的，而对于确定的状态，答案是唯一的合法表现在两方面：1.val&gt;0 2.所有的汉堡满足依赖这里的处理很优美:从一个合法状态到另一个合法状态，打标记12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;algorithm&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF=0x3f3f3f3f;int v[20],w[20];LL dp[(1&lt;&lt;16)]; //存放这种状态的最大收入LL en[1&lt;&lt;16];//........剩下的engint vis[1&lt;&lt;16];vector&lt;int&gt; sta[20];bool judge(int state,int add) //能不能把add加到这个状态下&#123; for(auto v:sta[add])&#123; if(!(state &amp; (1&lt;&lt;(v-1)))) return 0; &#125; return 1;&#125;int main()&#123; int t;cin&gt;&gt;t; while(t--)&#123; int n,E;cin&gt;&gt;n&gt;&gt;E; for(int i=0;i&lt;n;i++) cin&gt;&gt;v[i],sta[i].clear(); for(int i=0;i&lt;n;i++) cin&gt;&gt;w[i]; for(int i=0;i&lt;n;i++)&#123; int num;cin&gt;&gt;num; while(num--)&#123; int x;cin&gt;&gt;x; sta[i].pb(x); &#125; &#125; clr(dp,0); clr(vis,0); en[0] = E; vis[0]=1; LL ans=0; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123; if(vis[i]) for(int j=0;j&lt;n;j++) if(!(i&amp;(1&lt;&lt;j)) &amp;&amp; judge(i,j))&#123; if(en[i]-w[j] &lt; 0) continue; int now=i|(1&lt;&lt;j); dp[now] = dp[i]+v[j]; ans=max(ans,dp[now]); en[now] = en[i]-w[j]; vis[now]=1; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dp专题总结]]></title>
    <url>%2Funcategorized%2Fdp%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[dp专题总结 所有的dp关键有两点1.看出来这是一道dp题 （看时间复杂度）2.状态转移方程！！！！其中状态的确立和推出状态转移方程是个难点,而且dp题还经常会和其他知识点融合在一起搞你，非常灵活。先从有迹可循的一些经典dp问题入手 一.数位dp1.确立状态如何确立一个正确的dp数组？dp[pos][state1][state2][….]首先第一维代表着数位若是人为规定的话： 0-个位 1-十位 2-百位 3……那么后面的state代表的就是 所有的的i位数满足的性质eg. 如果要记录所有四的倍数的数量 （当然有更简单的容斥做法，这里只是举个例子）开 dp[pos][mod]那么dp[3][2]代表着所有千位数（0000-9999）中%4余2的个数 那怎么确定我们要开那些状态？1.题目中明确要求的2.影响状态转移的（前导0什么的）例如 http://acmoj.shu.edu.cn/problem/65/每组数据只有一行，包含三个整数 L_i,R_i,m。在 [L_i,R_i ] 区间，有多少个数奇偶和等于 m，以及这些数的和（对和取模100000007后输出）。 和 http://hihocoder.com/problemset/problem/1033描述给定一个数 x，设它十进制展从高位到低位上的数位依次是 a0, a1, …, an - 1，定义交错和函数：f(x) = a0 - a1 + a2 - … + ( - 1)n - 1an - 1例如：f(3214567) = 3 - 2 + 1 - 4 + 5 - 6 + 7 = 4给定 l, r, k，求在 [l, r] 区间中，所有 f(x) = k 的 x 的和，即： 这两道题非常像，但是不同的地方导致我们的状态方程也不一样。先考虑第一道题:对于pos位,我们想要得到答案dp[pos][sum] 只需从dp[pos-1][sum-sgn*i]转移而来，用代码来表示的话，就是：12345678910for(int i=0; i&lt;=up; i++) &#123; int val; if(i&amp;1) val=i*(-1); else val=i; node tmp=dfs ( pos-1, m - val, limit &amp;&amp; i == up); ans.num += tmp.num; ans.sum=(ans.sum+i*POW[pos]%mod*tmp.num%mod +tmp.sum)%mod; &#125; dp[pos][sum]:pos位数中满足奇偶和是sum的个数与其总和我们只需开多开一维sum记录 pos位数中满足奇偶和是sum的个数当前的加减与当前的i有关，与之前和之后的数无关，转移并不会冲突。 第二道题：我们能否也和上一题一样也开 dp[pos][sum]呢？那好，先来解释一下 如果只开两维 dp数组的意义：pos位数满足交错和为sum时的个数和总和乍一看没问题，但当你写状态转移的时候，就会发现状态该怎么转移？状态没法转移，当前是加，那么下一位就是减，反之亦然。你没有办法区分当前是正是负 还是前导0，当前状态的不同会导致之后状态也不一样。所以给每个数再加上个性质：当前位的符号dp[pos][sum][sgn]sgn: 0-有前导0 ,1-正, -1 负 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct node&#123; LL num,sum;&#125;dp[30][500][3]; //偏移量240//第三维代表leadint a[30];LL Pow[30];int k;//lead 0-有前导0 1-正 -1 负node dfs(int pos,bool limit,int lead,int sum)&#123; if(pos==-1)&#123; return node&#123;sum==0,0&#125;; &#125; if(!limit&amp;&amp; dp[pos][sum+240][lead].num!=-1) return dp[pos][sum+240][lead]; node ans=node&#123;0,0&#125;; int up=limit?a[pos]:9; for(int i=0;i&lt;=up;i++) &#123; //处理前导0 int sgn=1; if (lead==0 &amp;&amp; i==0) sgn=0; else if(lead==0 &amp;&amp; i!=0) sgn=1; else sgn=-lead; node tmp=dfs(pos-1,limit&amp;&amp;i==up,sgn,sum-sgn*i); LL num=tmp.num,sum=tmp.sum; (ans.num+=tmp.num)%=mod; ans.sum+=Pow[pos]*i %mod *num %mod+ sum; ans.sum%=mod; &#125; return limit?ans:dp[pos][sum+240][lead]=ans;&#125;LL solve(LL x)&#123; if(x==-1) return 0; int pos=0; while(x)&#123; a[pos++] = x%10; x/=10; &#125; return dfs(pos-1,1,0,k).sum;&#125; 其他难以确立的状态还有很多，比如大都会的四维dp，比如各种模数，连续字串。但最为关键的就是记住dp[pos][state1][state2][…]每多一个状态，那么就是pos位的数进一步被细分，可以看做是各种性质的交集，怎么去分这个数，就是确立状态的关键。 2.状态的转移其实状态的转移多多少少要在确立这个状态的时候一并考虑到了，毕竟状态要能正确的转移，我们才能说这个确立的状态是对的嘛。而数位dp的转移是比较单纯的，因为多半就是从高位到地位枚举，从低位到高位转移，而我们一般都是用数位dp记录满足条件数的个数，转移比较简单，写出dp数组，一般转移就出来了。那如果要记录所有满足条件数的总和，平方和，别的什么奇奇怪怪的东西呢？额，目前就遇到过 和 与 平方和。和：当前枚举的数×当前的位权×（要转移到的）低位的满足某性质的个数+（要转移到的）低位的满足某性质的个数eg：$ \cdots x \cdots $令$x_1~x_n$都是满足条件的低一位的数$ sum = （x+x_1）+(x+x_2)+ \cdots (x+x_n) =n*x + x_1+\cdots+x_n$开个struct 记录num和sum 平方和： $ ans = (x+x_1)^2 + (x+x_2)^2 + \cdots + (x+x_n)^2 $ &emsp;&emsp; $ =n*x^2+2x(x_1+x_2+ \cdots +x_n)$ 所以要维护三个值：个数 总和 平方和 eg https://vjudge.net/contest/70324#problem/J 二概率dp（期望dp）感觉都可以用数学简化，但数学功底不够，就用dp来凑]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 多校赛一]]></title>
    <url>%2Funcategorized%2F%E7%89%9B%E5%AE%A2-%E5%A4%9A%E6%A0%A1%E8%B5%9B%E4%B8%80%2F</url>
    <content type="text"><![CDATA[ALGV算法 抄一波 牛客的解释 （wiki 没耐心看了）作者：zzuzxy链接：https://www.nowcoder.com/discuss/87452?type=101&amp;order=0&amp;pos=1&amp;page=1LGV 算法 (Lindström–Gessel–Viennot lemma)求以上矩阵的行列式，其中 e(a,b) 是从a到b的方法数，带入求行列式即可得到(a1,a2,…an) 到 (b1,b2,…bn) 的所有不相交路径的种数再看这道题，其实就是要找从(n,0)到（0,m）的两条可重合的路径。如何将模型转移到不相交？一条路往左下角移一格a1,a2 ——- (n,0) (n-1,-1)b1,b2——— (0,m) (-1,m-1)e(a1,b1) = ….……ans= B Symmetric Matrix很有意思，从矩阵—关联到邻接矩阵（图论）—dp最终转换得到的题意是：给你n个不同的点，问能组成多少不同的环先考虑n个不同的球能组成多少不同的一个环 即：环排列 （n-1）!dp我是想不到的，那就走一遍吧：dp[n] 为数量为n的情况下，有多少的环的情况1.从n-1个点里找出1个点 与新加的点组成一个环(n-1)dp[n-2]2.从n-1个点中找出k个点 ，与新加的那个点组成一个环C(n-1,k) dp[n-k-1](k-1)!……………………………….死活推不出。。。这一数学题。老姐推出的。不贴代码了 就照着公式写f(n) = (n-1) f(n-2) +sum{k从2-(n-2)} ((n-1)!*f(k)/k!/2) E 大意：对于一个长度为 n 的由（1-k）组成的序列，去掉m个字符的不同子序列有多少个？ 由去掉m个字符组成子序列可以理解为只取（n-m）个字符组成的不同序列。首先遇到的问题是什么？同一个字符串可以有多种取法，那么如何筛除重复，就是这个问题的关键。1官方题解写的很不错。用dp做dp[i][j] 代表取第i个位置的数，且其中删除了j个数的情况数再去计算next[i][c] 代表第i个位置之后 第一个为c的位置（不包括位置i，且若是没有，统一为n+1）那么这样一来状态转移方程就是什么啊？dp[next[i][c]] [ next[i][c]-i-1+j ] +=dp[i][j]解释一下（我自己都看了好久。。。人蠢就要多努力）对于一串原序列与子序列：例如 原 1 2 1 2 1 1 2 1 子 1 1 2 （dp[4][1] ——-删了位置2） 对于 子序列 1 1 2 它下一个的取值有4种情况 恰好是pos 5~8，但是若是m=1（只删除一个）的话，pos 5，6，8就会多次记录，所以不能从位置四一一转移到 5 6 8，只能留一个，留哪个？很显然，留5，它是第一个出现的“1”，它的末尾可以接更多的值，就像直播时的前辈说的那样，这个有点贪心的感觉。如何去重的呢？看例子的位置 5 dp[5][0]=2 (11和21）怎么得到的11和21呢？位置是35和45只考虑这个数之前的第一个值。2之后看牛客别人的代码，发现大多数人不是这样做的，他们是如何处理的呢？dp[i][j]代表前i个位置，删j 个数的情况数（注意，这里不强制要求第i个数必须取，所以答案直接就是dp[n][m]）转移方程：dp( i , j ) = dp( i-1, j) +dp ( i-1, j-1) //第i个数不取+第i个数取显然，这里会有重复，我很好奇，他们是怎么处理重复的？if(pre[i]&amp;&amp;pre[i]+j-i&gt;=0) dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;额？这波操作有点秀啊，看不懂啊！！不过怎么这么熟悉呢if(pre[i]&amp;&amp;i-pre[i]&lt;=j)//如果位置i的前一个位置的数存在，并且能删那么多数 dp[i][j]=(dp[i][j]-dp[pre[i]-1][pre[i]+j-i]+mod)%mod;举例子：1 2 3 4 3 3 2 1到pos 5 就有问题了 序列123 13 23就会有重复了假设在pos5前dp[i][j] 一直保持它原本的意义 那么根据转移式dp[5][0] 没重复，不用减dp[5][1]没重复，不用减dp[5][2]重复出现了 且减去 dp[2][1] （对应123）dp[5][3] 减去 dp[2][2] （对应12，13 ）dp[5][4]…….都减去一个0（因为dp越界了）好神奇啊 为什么啊？有什么神奇的，就是字面意思嘛首先要减去的这个dp值的位置肯定是pre[i]-1因为之后才确定是哪个3嘛那j是多少呢 pre[i]+j-i 即 j -（ i-pre[i] ）中间都不删啊,(有中间的元素的话，就是一个新序列了嘛)3还有一种做法ans[len] 代表长度为len的序列种数nxt[len][num]代表长度为len，之后数字为num的种数那么 ans[len] += ans[len]-1 - nxt[len][a[i]]dp[i][j] = ans[j-1]//额 看不懂了，贴一下代码之后消化吧1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define N 2000050using namespace std;typedef long long LL;const int MAX=1e5+10;long long dp[MAX][20];const int MOD= 1e9+7;long long ans[MAX];long long a[MAX];int main()&#123; int n,m,k; while(~scanf("%d %d %d",&amp;n,&amp;m,&amp;k))&#123; for(int i=1;i&lt;=n;i++)&#123; ans[i]=0; memset(dp[i],0,sizeof dp[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; ans[0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=i;j&gt;=1 &amp;&amp; j&gt;=i-m-1;j--)&#123; ans[j]=(ans[j]+ans[j-1]-dp[j][a[i]])%MOD; dp[j][a[i]]=ans[j-1]; &#125; &#125; ans[n-m]=(ans[n-m]+MOD)%MOD; cout&lt;&lt;ans[n-m]&lt;&lt;endl; &#125;&#125;]]></content>
      <tags>
        <tag>acm</tag>
        <tag>dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kuangbin专题 搜索]]></title>
    <url>%2F%E6%90%9C%E7%B4%A2%2Fkuangbin%E4%B8%93%E9%A2%98-%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[E醉了，说有100位的十进制数，我想那会炸的啊，没想到啊，所有的答案都在long long范围内，那时候应该打个表看看 Fbfs 水题 G模拟题 怎么就搜索了？？没做 Hbfs + 记录路径怎么记录路径？记录每个点的前驱，像并查集那样向上跳，就是所求的路径。但这里有一个问题，它要准确打印操作是什么（我猜）就两个解决方法1：记录下来 就结构体里多加点东西咯2：打印答案路径的时候，对比v与前驱pre[v]，判断是什么我这里用了第二种方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;typedef pair&lt;int, int&gt; PII;int vol1,vol2,n;map &lt;PII,int &gt; vis;map &lt;PII,PII&gt; pre;int num;void ok()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;void dfs(PII tmp)&#123; if(pre.find(tmp)!=pre.end()) &#123; num++; dfs(pre[tmp]); int u1=tmp.X,v1=tmp.Y; int u2=pre[tmp].X,v2=pre[tmp].Y; if(u1+v1==u2+v2)&#123; cout&lt;&lt;"POUR("; if(u1&gt;u2) cout&lt;&lt;"2,1"; else cout&lt;&lt;"1,2"; cout&lt;&lt;")"&lt;&lt;endl; &#125; else if(u1==vol1&amp;&amp;u2!=vol1) cout&lt;&lt;"FILL(1)"&lt;&lt;endl; else if(v1==vol2&amp;&amp;v2!=vol2) cout&lt;&lt;"FILL(2)"&lt;&lt;endl; else if(u1==0&amp;&amp;u2!=0) cout&lt;&lt;"DROP(1)"&lt;&lt;endl; else if(v1==0&amp;&amp;v2!=0) cout&lt;&lt;"DROP(2)"&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;&#125;int main()&#123; while(cin&gt;&gt;vol1&gt;&gt;vol2&gt;&gt;n) &#123; vis.clear(); queue&lt;PII&gt; q; q.push(PII(0,0)); int finish=0; while(!q.empty()) &#123; PII tmp=q.front(); vis[tmp] = 1; q.pop(); int u=tmp.X,v=tmp.Y; if(u==n||v==n) &#123; num=0; dfs(tmp); finish=1; break; &#125; //三个操作 六种情况 int uu,vv; uu=vol1,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=vol2; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=0,vv=v; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=u,vv=0; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; uu=min((u+v),vol1),vv=u+v-uu; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; vv=min((u+v),vol2),uu=u+v-vv; if(!vis[PII(uu,vv)])&#123;q.push(PII(uu,vv));pre[PII(uu,vv)] = tmp;&#125; &#125; if(!finish) &#123;puts("impossible");continue;&#125; &#125; return 0;&#125; I - Fire Game FZU - 2150又一个神奇的oj 没c++11我写的好不习惯。不过这题还不错，让我折腾了好久。几个点：1.永远注意数据范围虽然数据小不意味着就要暴力，但这道题太tm小了，想用巧妙的方法做错了啊2.要用vis数组的话，push前就更新比较保险3.bfs别忘了pop，虽然总能debug出来，但好浪费时间啊，你就给我注意一下啊题本身倒没什么，暴力跑bfs就可以了，吐槽一下 n^6我tm写了四个循环，这怎么看都要t了，奈何不住数据小啊tips：看到一个优化在枚举的时候 第三重和第四重可以不用从0枚举12for(int ii=0;ii&lt;n;ii++) ==》 for(int ii=i;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) ==》 for(int jj=i==ii?j:0;jj&lt;m;jj++) 看大佬的代码 至于为什么。。。，容我三思 额，其实就是因为如果每行从自己开始的话会漏掉前面的一些点 或者干脆只优化一行，时间也没差多少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef unsigned long long LL;typedef pair&lt;int,int&gt; PII;const int INF = 0x3f3f3f3f;const double eps = 1e-6;int n,m;char G[20][20];int vis[20][20];int dis[20][20];int res;int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;inline bool check(int x,int y)&#123; return x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;G[x][y]=='#';&#125;void bfs(int x1,int y1,int x2,int y2)&#123; queue&lt;PII&gt; q; clr(vis,0); clr(dis,0); q.push(PII(x1,y1));vis[x1][y1]=1; q.push(PII(x2,y2));vis[x2][y2]=1; int ans=0; while(!q.empty())&#123; PII u=q.front(); q.pop(); ans=dis[u.X][u.Y]; for(int i=0;i&lt;4;i++)&#123; int xx=u.X+dx[i],yy=u.Y+dy[i]; if(check(xx,yy)&amp;&amp;!vis[xx][yy]) &#123; vis[xx][yy]=1; dis[xx][yy]=ans+1; q.push(PII(xx,yy)); &#125; &#125; &#125; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#'&amp;&amp;!vis[i][j]) return ; res=min(res,ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int k=1;k&lt;=t;k++)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf("%s",G[i]); res=INF; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(G[i][j]=='#') for(int ii=0;ii&lt;n;ii++) for(int jj=0;jj&lt;m;jj++) if(G[ii][jj]=='#') &#123; bfs(i,j,ii,jj); &#125; if(res==INF) res=-1; printf("Case %d: %d\n",k,res); &#125;&#125;]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>搜索</tag>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180717SHU暑期集训训练赛(6)===]]></title>
    <url>%2F2018%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%2F20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B-6%2F</url>
    <content type="text"><![CDATA[B D E K L是看过的题但没过 B蔡老师强啊 样例看了好久看不懂，磨到晚上蔡老师才指点迷津先解释样例1 2 有三组 就是3C2=3（1 2 ，3 1）和（3 1，1 2）为一组（1 2，1 2，3 1）和（1 2，3 1，1 2）为一组加起来五组 （这道题看似图论，跟图论没半毛钱关系）之前不小心看到题解了是hash，还是两次hash，怎么搞？想一想。想不出啊。让我猜猜看，边hash成一个值，多条边再hash成一个值？？不对啊 老哥额 还要一个公式 (n+1)C2 - nC2 = n就是说每加入一个新的值 ans都要加上 原有个数（注意不是n+1是n）相同值的hash值相加一样没问题，但不同的数的hash值相加会不会也一样？应该不一样把，人家都过了这道题了，hash不就是解决这个问题的嘛，不清楚，没学过。双hash函数 保证没有例外12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1&lt;&lt;12;//两个hash函数 所需seed 和 pLL seed1=13131313,seed2=23333333,mod1=1e9+7,mod2=1e9+9;LL p1[N],p2[N];map &lt;pair&lt;int,int&gt;,LL&gt; id;int a[N];map&lt;pair&lt;int,int&gt;,LL&gt; cnt[N];int main()&#123; p1[0]=p2[0]=1; for(int i=1; i&lt;N; i++) p1[i] = p1[i-1] * seed1 % mod1; for(int i=1; i&lt;N; i++) p2[i] = p2[i-1] * seed2 % mod2;//这两步的意义是处理什么？写hash函数 fastin int t; cin&gt;&gt;t; while(t--) &#123; id.clear(); int n; cin&gt;&gt;n; for(int i=0,x,y; i&lt;n; i++) &#123; //将边hash成一个id值 cin&gt;&gt;x&gt;&gt;y; if(x&gt;y) swap(x,y); if(id.find(&#123;x,y&#125;)==id.end()) id[&#123;x,y&#125;] = id.size(); a[i] = id[&#123;x,y&#125;] ; &#125; LL ans=0; for(int i=0; i&lt;=n; i++) cnt[i].clear(); for(int i=0; i&lt;n; i++) &#123; LL sum1=0,sum2=0; for(int j=i; j&lt;n; j++) &#123; (sum1+= p1[a[j]]) %=mod1; (sum2+= p2[a[j]]) %=mod2; ans+=cnt[j-i][ &#123;sum1,sum2&#125;]; //厉害啊 想不到 cnt[j-i][ &#123;sum1,sum2&#125;]++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 半抄半做的题，到时候再重新做一下 D The main idea is that we only need to keep track of the number of active cells and the last strictly increasing sequence of powers from right to left, this is because if we have a cell with number X and the cell to the right has number Y where Y &gt; X , these two cells will never merge and therefore anything to the left of them won’t add anything to the score so we don’t need to keep track of them.This leads to a DP Bitmask solution where we store the bitmask of available powers of 2 (they are guaranteed to be strictly increasing from right to left because we ignore any powers that aren’t) and the number of active cells (free cells + number of bits in the mask).If the current mask is msk and a 4 is generated, the new mask will become msk + 4 and ((msk)^(msk + 4)) - 4 will be added to the score.When a 2 is generated, the new mask will become msk + 2 and ((msk)^(msk + 2)) - 2 will be added to the score.The added score explained above is the score added from all the merge operations that will happen after adding the new number, not only the first one. Merging them all at once will not affect the final answer.^ is the bitwise XOR operator. 毫无头绪，不好意思英文的题解，慢慢啃吧尽力了 下一道E。。。。下一道 K生成树 ，李老师说的对啊，我错了先找到环上的任意一条边，去掉它，这张图就成为一个树了那么不考虑去掉的那条边，就是一个lca问题。只是在这里没有那么简单，要考虑经过那条边的情况，无非多出两种情况总共三种情况 1.不经过u—-v lcm //不经过去掉的边2.从u到v w+x—u+y—v3.从v到u w+x—v+y—u 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=1e5+10;struct edge&#123; int to; LL w;&#125;;vector&lt;edge&gt; G[N];int father[N];int Find(int x)&#123; return x==father[x] ? x : father[x]=Find(father[x]);&#125;void Union(int x,int y)&#123; int rx=Find(x),ry=Find(y); if(rx==ry) return ; father[rx]=ry;&#125;//lca 一dfs处理深度 和faint dep[N],fa[N][30];LL d[N];//i到1的距离int n,q;void dfs(int u,int pre,LL dis)&#123; fa[u][0]=pre; d[u] = dis; for(auto tmp:G[u]) &#123; int v=tmp.to; LL distance=tmp.w; if(v!=pre) &#123; dep[v]=dep[u]+1; dfs(v,u,d[u]+distance); &#125; &#125;&#125;void bz()&#123; for(int j=1; j&lt;=29; j++) for(int i=1; i&lt;=n; i++) fa[i][j] = fa[fa[i][j-1]][j-1];&#125;void LCAinit()&#123; clr(dep,0); dep[1]=1; clr(d,INF); dfs(1,0,0); bz();&#125;int LCA(int u,int v)&#123; if(dep[u]&gt;dep[v]) &#123; swap(u,v); &#125; int cha = dep[v] - dep[u]; int len = log2(n); for(int x=0; x&lt;=len; x++) if((1&lt;&lt;x)&amp;cha) v=fa[v][x]; if(u==v) return u; for(int x=len; x&gt;=0; x--) &#123; if(fa[v][x]!=fa[u][x]) &#123; u=fa[u][x]; v=fa[v][x]; &#125; &#125; return fa[u][0];&#125;LL dis(int x,int y)&#123; int c=LCA(x,y); return d[x]+d[y]-2*d[c];&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; for(int i=0;i&lt;=n;i++) G[i].clear(); scanf("%d%d",&amp;n,&amp;q); for(int i=0; i&lt;=n; i++) father[i]=i; int in,out,w; for(int i=0,x,y; i&lt;n; i++) &#123; LL val; scanf("%d%d%lld",&amp;x,&amp;y,&amp;val); if(Find(x)==Find(y)) &#123; in=x,out=y,w=val; &#125; else &#123; Union(x,y); G[x].push_back(edge&#123;y,val&#125;); G[y].push_back(edge&#123;x,val&#125;); &#125; &#125; LCAinit(); for(int i=0,x,y; i&lt;q; i++) &#123; scanf("%d%d",&amp;x,&amp;y); LL ans=dis(x,y); ans=min(ans,dis(x,in)+dis(out,y)+w); ans=min(ans,dis(x,out)+dis(in,y)+w); printf("%lld\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS]]></title>
    <url>%2Funcategorized%2FLCS%2F</url>
    <content type="text"><![CDATA[给出两个串 ，输出最长公共子序列学习地址：https://blog.csdn.net/zhijianshafeiyang/article/details/45034853 “用一个数组将第一个串内元素在第二个串内的位置保存下来，求这个数组的最长上升子序列长度”什么叫第一个串内元素在第二个串内的位置？比如 str1 = avbasx str2 = abcaszx 位置是反序 就是 4，1——2——4，1——5——7eg2： aaba abaa 4 3 1 —— 4 3 1—— 2 —— 4 3 1 两个问题 1.记录位置 2.位置的反序 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int INF = 0x3f3f3f3f;const int MAX = 100000;//---------------int ans[MAX];vector&lt;int&gt; a;int LIS()&#123; int len=1; ans[0]=a[0]; for(int i=1;i&lt;a.size();i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++] = a[i]; else *lower_bound(ans,ans+len,a[i]) = a[i]; &#125; return len;&#125;//--int a1[MAX],a2[MAX];int LCSlen1,LCSlen2;int LCS()&#123; map&lt;int,int&gt; pos; a.clear(); for(int i=0;i&lt;LCSlen1;i++)&#123; pos[a1[i]] = i; &#125; for(int i=0;i&lt;LCSlen2;i++)&#123; if(pos.find(a2[i])!=pos.end()) a.pb(pos[a2[i]]); &#125; return LIS();&#125; 区域赛更新1234567891011121314int a[100100],ans[100100];int LIS(int n)&#123; ans[0]=a[0]; int len=1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&gt;ans[len-1]) ans[len++]=a[i]; else&#123; int pos=lower_bound(ans,ans+len,a[i])-ans; //在答案里找第一个比a[i]大的位置 ans[pos]=a[i]; &#125; &#125; return len;&#125;]]></content>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716SHU暑期集训组队赛(5)===]]></title>
    <url>%2F2018%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%2F20180717SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E7%BB%84%E9%98%9F%E8%B5%9B-5%2F</url>
    <content type="text"><![CDATA[又tm垫底了两道图论+二分答案没过模板 迪杰斯特拉最短路 + 二分答案 二分图匹配+二分答案特点：最大化其中最小值（最小化其中最大值）多源bfs？最小化最远距离（对于状态而言） https://vjudge.net/contest/237325#problem/D（）先打两个模板压压惊，去洛谷啊 E dij+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const LL INF = LL(1)&lt;&lt;50;const int mod = 1e9 + 7;const double eps = 1e-6;const int N=10010;const int M=500010;struct node&#123; int x; LL val; bool operator &lt; (const node&amp;a)const &#123; return val&gt;a.val; &#125;&#125;;vector&lt;node&gt; G[N];int vis[N];LL dis[N];int n,m,x;int mz;bool Dij(LL lim)&#123; clr(vis,0); for(int i=0;i&lt;=n;i++) dis[i]=INF; priority_queue&lt;node&gt; q; dis[1]=0; q.push(node&#123;1,0&#125;); node tmp; while(!q.empty()) &#123; tmp=q.top(); q.pop(); int u=tmp.x; if(vis[u]) continue; vis[u]=1; for(auto nd:G[u]) &#123; int v=nd.x; LL cost=nd.val; if(cost &gt; lim) continue; if(!vis[v]&amp;&amp;dis[v]&gt;dis[u]+cost) &#123; dis[v]=dis[u]+cost; q.push(node&#123;v,dis[v]&#125;); &#125; &#125; &#125; if(dis[n]&lt;=mz) return true; return false;&#125;void showg()&#123; for(int i=1;i&lt;=n;i++)&#123; for(auto v:G[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.val; cout&lt;&lt;endl; &#125;&#125;int main()&#123; fastin cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=0,u,v;i&lt;m;i++)&#123; LL dis; cin&gt;&gt;u&gt;&gt;v&gt;&gt;dis; G[u].push_back (node&#123;v,dis&#125;); G[v].push_back (node&#123;u,dis&#125;); &#125; Dij(1e7); mz=dis[n]*(1.0+x/100.0); LL l=0,r=INF; while(r-l&gt;1)&#123; LL mid=l+(r-l)/2; if( Dij(mid) ) r=mid; else l=mid; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; J 二分图匹配+二分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;const int N=5010;const int M=50010;vector&lt;int&gt; G[N];int link[N],used[N];int n,m;int uN;bool dfs(int u)&#123; for(auto v:G[u]) &#123; if(!used[v]) &#123; used[v]=1; if(link[v]==-1||dfs(link[v])) &#123; link[v]=u; return true; &#125; &#125; &#125; return false;&#125;int hungary()&#123; int res=0; memset(link,-1,sizeof link); for(int u=1; u&lt;=uN; u++) &#123; clr(used,0); if(dfs(u)) res++; &#125; return res;&#125;int dis[110][110];bool judge(int lim)&#123; for(int i=0; i&lt;=n; i++) G[i].clear(); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) if(dis[i][j]&lt;=lim) &#123; G[i].pb(j+n); G[j+n].pb(i); &#125; return hungary()==n;&#125;int xx[240];int yy[240];int main()&#123; fastin cin&gt;&gt;n; uN=n; for(int i=1; i&lt;=2*n; i++) &#123; cin&gt;&gt;xx[i]&gt;&gt;yy[i]; &#125; for(int i=1; i&lt;=n; i++) for(int j=n+1; j&lt;=2*n; j++) dis[i][j-n] = abs(xx[i]-xx[j])+abs(yy[i]-yy[j]); int l=0,r=1e8; while(r-l&gt;1) &#123; int mid=l+(r-l)/2; if(judge(mid)) r=mid; else l=mid; //cout&lt;&lt;mid&lt;&lt;endl; &#125; cout&lt;&lt;r&lt;&lt;endl; return 0;&#125; 二分答案题感觉都是00000000000001111111111111111111（求第一个1）或11111111111111110000000000000000（求第一个0）而不能解决 类似于0111111000011111000011111000000（求第一个0）记住就好了 G大意：有多个点，对于每个点，给定它的坐标和曼哈顿半径，求有几个交点0个就impossible 1就输出那个交点 2就uncertain最多 4e61+1e6 1000好气啊 当时都想出来了 复杂度推错了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const double eps = 1e-6;struct node&#123; int x,y; bool operator&lt; (const node&amp;a)const &#123; return x&lt;a.x; &#125;&#125;;vector&lt;node&gt; st[2];int main()&#123; fastin int n;cin&gt;&gt;n; int x,y,dis;cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(int i=-dis;i&lt;=dis;i++)&#123; st[0].push_back(node&#123;x+i,y+dis-abs(i)&#125;); if(i!=-dis &amp;&amp; i!= dis) st[0].push_back(node&#123;x+i,y-dis+abs(i)&#125;); &#125; int flag=1; for(int i=1;i&lt;n;i++)&#123; st[flag].clear(); cin&gt;&gt;x&gt;&gt;y&gt;&gt;dis; for(auto v:st[1^flag]) if(abs(x-v.x)+abs(y-v.y)==dis) st[flag].push_back(node&#123;v.x,v.y&#125;); flag^=1; &#125; flag^=1; /* for(int i=0;i&lt;2;i++)&#123; for(auto v:st[i]) cout&lt;&lt;v.x&lt;&lt;" "&lt;&lt;v.y&lt;&lt;endl; cout&lt;&lt;endl; &#125; */ if(st[flag].size()==1) cout&lt;&lt;st[flag][0].x&lt;&lt;" "&lt;&lt;st[flag][0].y&lt;&lt;endl; else if(st[flag].size()==0) puts("impossible"); else puts("uncertain"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>二分</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[===20180716 SHU暑期集训个人赛(3)===]]></title>
    <url>%2F2018%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%2F%3D%3D%3D20180716SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E8%AE%AD%E7%BB%83%E8%B5%9B(3)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[垫底之旅2016-2017 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2016) 看的题 但没做出来 感觉都在能力范围之内 就是没想到 A倒跑并查集也蛮难写的 也要把一个点hash成一个值 就是二维变一维嘛这 怎么想的到 Btire树上的bfstire树都不知道是是什么 你让我怎么做 C对一副乱序的扑克牌求排有序的最小_交换相邻元素的_操作个数首先数据规模很小 （最多52张牌嘛）先想想最暴力的做法咯 就对于给定的一副牌排序的结果无非是 4!（花色全排列）*2^4（顺序和倒序）种结果 384例如样例12h Th 8c Qh所有的可能性 1.2h Th Qh 8c 2.8c 2h Th Qh还有倒序的，不写了那验证每一种初态到给定态的检查的方法复杂度要多少啊？不知道啊 卡住了啊 看题解。。。怎么就LCS了拉 我怎么不知道什么意思啊？那就考虑一个更简单的模型一串乱序的数字序列 需要相邻元素交换几次才能变为不下降序列？额 不需要相邻元素 随便交换 又读错题了。。。。Sorting is done by moving one card at a time fromits current position to a new position in the hand, atthe start, end, or in between two adjacent cards. Whatis the smallest number of moves required to sort agiven hand of cards?枚举4！种排列组合 和2^4 正序 倒序 暴力求解求出最大的LCS就可以拉有个小tips：A是王牌 是最大的。。。。wa了好几发 读题读题看错题太蠢了 F推公式 排列组合题 ，没什么难度 但我推不出 H见过一道差不多的，没去写，亏了。找了半个小时没找到 算了。额 我错了 看了那么久 还是看不懂抄一遍代码 找感觉吧额 又看了一遍题目。知道了，感觉有意思。大意是：给n个矩形，让他们一个一个往上叠，约束条件是 宽严格递减（矩形可以旋转，所以长宽可以交换），求最大高度。（n个矩形都要用到）1，建图。当时第一步都没想到，鬼知道要长宽相连建图啊，但其实应该知道，这已经不是第一次遇到了。（第二次）建图前想一想，该怎么建图，如果单纯相连，那图的意义，边的意义，点的意义是什么？这里主要是边的意义,认为规定 a-&gt;b的有向边是这个矩形啊 a为宽，b为高放置。（鬼才想的到，我想不到。）利用约束条件有对这个图产生了新的限制：一个点最多一个出度（这个点只能做一次宽）这个图可能有许多连通分支，就挑一个来看，这个连通分支有什么特点2，已知：输入保证n个矩形能叠起来那上界，n个点是不是最多n条边？ 额，不知道。证明一下咯，如果有n+1条边，至少一个点的出度&gt;=2.有n条边，那连通分支中有一个环，再加一条边，又多一个环，就是说，n+1条边的无向图中有两个环一个环已经自给自足了，没法有出度的边了，那只能别人进去，有两个别人需要进去的点（环缩点），那势必有一个点需要出度两次。 所以n个点的连通分支最多只有n条边。 考虑下界，n个点的连通分支最少有n-1条边（一棵树，真的不能再少了，再少就两个连通分支了。。。）所以只有两种情况，n个点n条边，每个点都出度一次n个点n-1条边，有一个点无需出（哪个点不用做宽啊，哪肯定是值最大的那个啊，给我滚去做高啊） 那怎么写啊。。。。。额 抄一波代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;const int N = 5e5;vector&lt;int&gt;G[N];int val[N];int vis[N];int sz=0;int maxv,deg;LL ans=0;map&lt;int,int&gt; id;void dfs(int u)&#123; vis[u]=1; deg+=G[u].size()-2; //妙啊 一条边贡献两个度数，要是树的话，只有2n-2个总度数 ans+=LL(val[u])*(G[u].size()-1); maxv=max(maxv,val[u]); //维护最大点 for(auto v:G[u])&#123; if(!vis[v]) dfs(v); &#125;&#125;int main()&#123; int n;cin&gt;&gt;n; for(int i=0,x,y;i&lt;n;i++)&#123; cin&gt;&gt;x&gt;&gt;y; if(id.find(x)==id.end()) id[x]=++sz,val[sz]=x; //缩点 if(id.find(y)==id.end()) id[y]=++sz,val[sz]=y; G[id[x]].pb(id[y]); G[id[y]].pb(id[x]); &#125; clr(vis,0); ans=0; for(int i=1;i&lt;=sz;i++)&#123; if(!vis[i]) &#123; maxv=0,deg=0; dfs(i); if(deg!=0) ans+=maxv; //是个树加上最大的那个点 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>并查集</tag>
        <tag>倒跑</tag>
        <tag>字典树</tag>
        <tag>排列组合</tag>
        <tag>图论</tag>
        <tag>连通性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20180619 SHU暑期集训个人赛(1)]]></title>
    <url>%2F2018%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%2F%3D%3D%3D20180619SHU%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD%E4%B8%AA%E4%BA%BA%E8%B5%9B(1)%3D%3D%3D%2F</url>
    <content type="text"><![CDATA[A - Subarrays Beauty Gym - 101532A 找规律 注意位运算 多半是对位的找规律 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[100010];LL b[100010];int n;LL func(LL x)&#123; return x*(x+1)/2;&#125;LL coun()&#123; LL num=0; LL ans=0; for(int i=0;i&lt;n;i++)&#123; if(num&gt;0&amp;&amp;b[i]==0) &#123; ans+=func(num);num=0; &#125; if(b[i]==1) num++; &#125; ans+=func(num); return ans;&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);LL _max=0; for(int i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]);_max=max(_max,a[i]); &#125; int wei=log2(_max); wei+=2; LL ans=0; LL basic=1; for(int i=0;i&lt;wei;i++,basic&lt;&lt;=1)&#123; for(int j=0;j&lt;n;j++)&#123; b[j]= a[j]&amp;1; a[j]&gt;&gt;=1; &#125; ans+=basic*coun(); &#125; printf("%lld\n",ans); &#125; return 0;&#125;/*237 11 9411 9 6 11*/ B - Array Reconstructing Gym - 101532B 简单题 我都记不清是什么题了 多半是尝试 打印答案 //想起华师的第二道题 妈的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[1010];int n;void print_ans(int x,LL val,LL m)&#123; for(int i=x+1;i&lt;n;i++)&#123; a[i]=(a[i-1]+1)%m; &#125; for(int i=x-1;i&gt;=0;i--)&#123; a[i]=(a[i+1]-1+m)%m; &#125; for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;a[n-1]&lt;&lt;endl;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; LL m;cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) if(a[i]!=-1) &#123;print_ans(i,a[i],m);break;&#125; &#125; return 0;&#125;/*45 101 2 3 4 54 107 -1 9 -16 75 -1 -1 1 2 36 105 -1 7 -1 9 0*/ C - Large Summation Gym - 101532C二分 没什么特殊的 没接触过罢了lower_bound() &gt;=upper_bound() &gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;struct node&#123; int no; int val; int ans;&#125;;int n;node a[200100];bool cmp1(node a,node b)&#123; return a.val&lt;b.val;&#125;bool cmp2(node a,node b)&#123; return a.no&lt;b.no;&#125;int findkey(int val,int pos)&#123; int l=0,r=n-1; int mid; while(l&lt;=r)&#123; mid=(l+r)/2; if(a[mid].val&gt;val) r=mid-1; else l=mid+1; &#125; if(r==pos) r--; if(r&lt;0) return a[(pos+1)%n].val; return a[r].val;&#125;int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123;cin&gt;&gt;a[i].val;a[i].no=i;&#125; sort(a,a+n,cmp1); for(int i=0;i&lt;n;i++)&#123; int ans1; if(i==n-1) ans1=(a[n-2].val+a[n-1].val)%mod; else ans1=(a[n-1].val+a[i].val)%mod; int tmp=findkey(mod-a[i].val-1,i); int ans2=(a[i].val+tmp)%mod; a[i].ans=max(ans1,ans2); &#125; sort(a,a+n,cmp2); for(int i=0;i&lt;n-1;i++) cout&lt;&lt;a[i].ans&lt;&lt;" "; cout&lt;&lt;a[n-1].ans&lt;&lt;endl; &#125; return 0;&#125;/*331 2 321000000000 10000000003500000007 500000002 500000003*/ D - Counting Test Gym - 101532D 预处理+查询注意l-r可以处理为 (1~r) - (1~l-1) 简单好多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;LL a[10010][26];char tmp;LL func(LL s,LL e)&#123; if(s==0) return a[e][tmp-'a']; return a[e][tmp-'a']-a[s-1][tmp-'a'];&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n,m; scanf("%d %d",&amp;n,&amp;m); memset(a,0,sizeof a); string s;cin&gt;&gt;s; a[0][s[0]-'a']++; for(int i=1;i&lt;n;i++)&#123; int num=s[i]-'a'; a[i][num]++; for(int j=0;j&lt;26;j++) a[i][j]+=a[i-1][j]; &#125; for(int i=0;i&lt;m;i++)&#123; LL ans=0; LL l,r;scanf("%lld %lld %c",&amp;l,&amp;r,&amp;tmp); l-=1;r-=1; if(r-l&lt;n)&#123; r%=n,l%=n; if(r&gt;=l) ans+=func(l,r); else&#123; ans+=func(l,n-1); ans+=func(0,r); &#125; &#125; else&#123; LL len1=r%n,len2=n-l%n; ans+=func(l%n,n-1); ans+=func(0,r%n); ans+=(r-l-len1-len2) / n * a[n-1][tmp-'a']; &#125; printf("%lld\n",ans); &#125; &#125;&#125;/*18 5abcabdca1 1 c1 15 b4 9 a5 25 d2 7 c*/ E - Game of Dice Gym - 101532E折半查找 第一次做 还可以12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const double eps = 1e-6;LL a[500][7];map&lt;LL,int&gt; c;int n;LL m;LL res=0;long long quickmod(long long a,long long b,long long m)&#123; long long ans = 1; while(b)&#123; if(b&amp;1)&#123; ans = (ans*a)%m;b--; &#125; b/=2; a = a*a%m; &#125; return ans;&#125;void dfs1(int cur,int e,LL ans)&#123; if(cur==e)&#123; ++c[ans]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs1(cur+1,e,(ans*a[cur][i])%mod); &#125;&#125;void dfs2(int cur,int e,LL ans)&#123; if(cur==e)&#123; res+=c[(m*quickmod(ans,mod-2,mod))%mod]; return ; &#125; for(int i=0;i&lt;6;i++) &#123; dfs2(cur+1,e,(ans*a[cur][i])%mod); //SDUSHADJKASDNJKASDHJK &#125;&#125;void init()&#123; res=0; c.clear();&#125;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; scanf("%d %lld",&amp;n,&amp;m); init(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;6;j++) scanf("%lld",&amp;a[i][j]); int mid=n/2; dfs1(0,mid,LL(1)); dfs2(mid,n,LL(1)); cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; F - Strings and Queries Gym - 101532F 1.hash2.暴力枚举回文子串数量3.st处理区间问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int func(char s[])&#123; LL ans=0; int n=strlen(s); for(int i=0; i&lt;n; i++) &#123; for(int len=1; len&lt;n; len++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len]) ans++; else break; &#125; &#125; for(int i=0; i&lt;n-1; i++) if(s[i+1]==s[i]) &#123; ans++; for(int len=1; len&lt;n; i++) &#123; if(i-len&lt;0||i+len&gt;n) break; if(s[i-len]==s[i+len+1]) ans++; else break; &#125; &#125; return ans;&#125;int c[40][40];int func1(string s)&#123; int len=s.size(); int sum=0; memset(c,0,sizeof c); for(int i=len-1; i&gt;=0; i--) &#123; c[i][i]=true; sum++; for(int j=i+1; j&lt;len; j++) &#123; if(s[i]==s[j]) &#123; if(i+1==j||c[i+1][j-1]) &#123; c[i][j]=true; sum++; &#125; &#125; else c[i][j]=false; &#125; &#125; return sum;&#125;LL Hash(string s)&#123; LL ans=0; int len=s.size(); for(int i=0; i&lt;len; i++) &#123; ans=ans*31+s[i]-'a'+1; &#125; return ans;&#125;struct node&#123; int no; int val; node(int n=0,int v=0) &#123; no=n; val=v; &#125; bool operator &lt; (const node&amp; a) const &#123; if(val==a.val) return no&gt;a.no; return val&lt;a.val; &#125;&#125;;char s[40];int n;node dp[10100][40];void st()&#123; for(int j=1;(1&lt;&lt;j)&lt;=n;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) dp[i][j]=max(dp[i][j-1],dp[i+(1&lt;&lt;(j-1))][j-1]);&#125;node RMQ(int l,int r)&#123; int k=log2(r-l+1); return max(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; map&lt;LL,int&gt; mp; int q; scanf("%d%d",&amp;n,&amp;q); for(int i=1; i&lt;=n; i++) &#123; scanf("%s",s); int num=func1(s); LL hs=Hash(s); mp[hs]=i; dp[i][0]=node(i,num); &#125; st(); for(int i=1; i&lt;=q; i++) &#123; char tmp1[40],tmp2[40]; scanf("%s",tmp1); scanf("%s",tmp2); LL hs1=Hash(tmp1),hs2=Hash(tmp2); int n1=mp[hs1],n2=mp[hs2]; if(n1&gt;n2) swap(n1,n2); printf("%d\n",RMQ(n1,n2).no); &#125; &#125; return 0;&#125;int main1()&#123; cout&lt;&lt;Hash("aaaa")&lt;&lt;endl; cout&lt;&lt;Hash("aaaaa")&lt;&lt;endl;&#125;/*35 5aaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbcccaaaaccccaaaaaaaaaaaaaaaaccccccacccccc aaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa cccaaaaccccaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaacccccc aaaaaaaaaaaaa*/ G - Magical Indices Gym - 101532G 前缀 后缀 签到题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;int a[1000100];int maxtou[1000100];int minwei[1000100];int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i==0) maxtou[0]=a[0]; else maxtou[i]=max(maxtou[i-1],a[i]); &#125; minwei[n-1]=a[n-1]; for(int i=n-2;i&gt;=0;i--)&#123; minwei[i]=min(minwei[i+1],a[i]); &#125; int ans=0; for(int i=1;i&lt;n-1;i++)&#123; if(a[i]&lt;=minwei[i+1]&amp;&amp;a[i]&gt;=maxtou[i-1]) ans++; //cout&lt;&lt;a[i].index&lt;&lt;" "; &#125; printf("%d\n",ans); &#125; return 0;&#125;/*4101 2 1 1 1 1 1 1 1 153 3 4 5 3*/``` ## H - Corrupted Images Gym - 101532H 签到题注意角上的 唯一的坑点了吧```c++#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long double Ld;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;char a[60][60];int main()&#123; fastin int t;cin&gt;&gt;t; while(t--)&#123; int n,m;cin&gt;&gt;n&gt;&gt;m; int num=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='1') num++; &#125; if( num&lt;(2*n+2*m-4) ) &#123;cout&lt;&lt;"-1"&lt;&lt;endl;continue;&#125; int ans=0; for(int j=0;j&lt;m;j++)&#123; if(a[0][j]=='0') ans++; if(a[n-1][j]=='0') ans++; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i][0]=='0') ans++; if(a[i][m-1]=='0') ans++; &#125; if(a[0][0]=='0') ans--; if(a[n-1][0]=='0') ans--; if(a[0][m-1]=='0') ans--; if(a[n-1][m-1]=='0') ans--; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; I - The Crazy Jumper Gym - 101532I dp注意下一个元素是要特殊处理 不然会超时一步步覆盖 从头想想从尾部会怎么样？12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int a[200110];int pos[200110];int dp[200110];int n;int main()&#123; int t;scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); dp[0]=-1; memset(pos,0,sizeof pos); for(int i=1;i&lt;=n;i++)&#123; int val; scanf("%d",&amp;val); dp[i]=dp[i-1]+1; if(pos[val]!=0) dp[i]= min ( dp[i] , dp[ pos[val] ]+1); pos[val] = i ; &#125; printf("%d\n",dp[n]); &#125;&#125; J - The Hell Boy Gym - 101532J 公式 或者 递推数学问题12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int mod = 1e9+7;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int n;scanf("%d",&amp;n); LL ans=1,tmp; while(n--) &#123;scanf("%lld",&amp;tmp); ans=(ans*(tmp+1))%mod;&#125; printf("%lld\n",(ans+mod-1)%mod); &#125; return 0;&#125; K - Palindromes Building Gym - 101532K 组合数学123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;int P[12];void pre()&#123; P[0]=1; for(int i=1;i&lt;=11;i++) P[i]=i*P[i-1];&#125;int main()&#123; pre(); int t;cin&gt;&gt;t; while(t--) &#123; int n;int l[26]; memset(l,0,sizeof l); cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; char tmp;cin&gt;&gt;tmp; l[tmp-'a']++; &#125; int num=0; for(int i=0;i&lt;26;i++) if(l[i]&amp;1) num++; if(num&gt;=2)&#123; cout&lt;&lt;0&lt;&lt;endl;continue;&#125; int len=0; for(int i=0;i&lt;26;i++) &#123;l[i]/=2;len+=l[i];&#125; int ans=P[len]; for(int i=0;i&lt;26;i++) &#123;ans/=P[l[i]];&#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; L - List Of Integers CodeForces - 920G 二分答案 之后容斥验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;#define clr(a, x) memset(a, x, sizeof(a))#define mp(x, y) make_pair(x, y)#define pb(x) push_back(x)#define X first#define Y second#define fastin \ ios_base::sync_with_stdio(0); \ cin.tie(0);typedef long long LL;typedef long long ll;typedef pair&lt;int, int&gt; PII;typedef vector&lt;int&gt; VI;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const double eps = 1e-6;void show()&#123; cout&lt;&lt;"ok"&lt;&lt;endl;&#125;vector&lt;LL&gt; vec;LL cnum(LL r) //求1-r中与 k（不）互质 的元素的个数&#123; LL ans=0; int wei=vec.size(); for(LL i=1; i&lt;(1LL&lt;&lt;wei); i++) &#123; int bits=0,multi=1; for(LL j=0; j&lt;wei; j++) &#123; if(i&amp;(1LL&lt;&lt;j)) &#123; bits++; multi*=vec[j]; &#125; &#125; LL cur=r/multi; if(bits&amp;1) ans+=cur; else ans-=cur; &#125; //return ans; //返回与其不互质的元素个数 return r-ans;//返回与其互质的元素个数&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--) &#123; LL l,no, p; scanf("%lld%lld%lld",&amp;l,&amp;p,&amp;no); vec.clear(); LL ans=0; for(LL i=2; i*i&lt;=p; i++) &#123; if(p%i==0) vec.push_back(i); while(p%i==0) p/=i; &#125; if(p&gt;1) vec.push_back(p); LL r=1e12; LL tmp=no+cnum(l); while(l&lt;=r) &#123; LL mid=l+(r-l)/2; if(cnum(mid)&gt;=tmp) &#123; ans=mid; r=mid-1; &#125; else l=mid+1; &#125; printf("%lld\n",ans); &#125; return 0;&#125; N - Sleepy GameCodeForces - 936B 三种简单图论知识的集合题 1.有向图 dfs判环 vis[] 标记 三种标记 0代表未访问 1代表正在访问这个分支 2代表访问完成某一分支 什么时候会形成环？ 这个点的分支在访问的时候又回到了自己这个点 蔡老师强啊 一般我会写 1234567891011121314bool huan(int u)&#123; bool flag=false; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1) return true; else if(c[v]==0)&#123; if(huan(v)) flag=true; &#125; &#125; c[u]=2; return flag;&#125; 又丑又长12345678910bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125; 对判环理解很深刻（&amp;&amp;与||优先级 不要怕 大胆写啊） 2.拆点一张图拆成两张图 偶数路径 奇数路径偶-奇-偶-。。。。。奇-偶-奇。。。一个点可能既可以在 两种情况下 都被访问 用vis[MAXN][2]全记录下来3.打印路径记录每个点在奇偶路径下的父亲 回溯输出//一开始暴力从始点枚举。。RE了多半递归炸了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const int mod = 1e9 + 7;const int MAXN = 200100;vector&lt;int&gt; G[MAXN&lt;&lt;1];int n,m;int vis[MAXN][2];//1--到。。。可以为奇数路径int fa[MAXN][2];//0--到。。。可以为偶数路径void dfs(int s,int flag) //处理出s点的可走路径奇偶&#123; vis[s][flag]=1; for(auto v:G[s]) &#123; if(!vis[v][1-flag]) &#123; fa[v][1-flag]=s; dfs(v,1-flag); &#125; &#125;&#125;void print_ans(int u,int flag)&#123; if(u==0) &#123; return ; &#125; //cout&lt;&lt;u&lt;&lt;" "&lt;&lt;flag&lt;&lt;endl; //cout&lt;&lt;fa[u][flag]&lt;&lt;endl; print_ans(fa[u][flag],1-flag); cout&lt;&lt;u&lt;&lt;" ";&#125;void show()&#123; cout&lt;&lt;endl; cout&lt;&lt;fa[5][1]&lt;&lt;endl; cout&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=0; j&lt;2; j++) cout&lt;&lt;fa[i][j]&lt;&lt;" "; cout&lt;&lt;endl; &#125;&#125;int c[MAXN];bool huan(int u)&#123; c[u]=1; for(auto v:G[u]) &#123; if(c[v]==1||c[v]==0&amp;&amp;huan(v)) return true; &#125; c[u]=2; return false;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; memset(vis,0,sizeof vis); for(int i=1; i&lt;=n; i++) &#123; int num; cin&gt;&gt;num; for(int j=0; j&lt;num; j++) &#123; int to; cin&gt;&gt;to; G[i].push_back(to); &#125; &#125; int s; cin&gt;&gt;s; memset(fa,0,sizeof fa); dfs(s,0); for(int i=1; i&lt;=n; i++) if(G[i].empty()&amp;&amp;vis[i][1]) &#123; cout&lt;&lt;"Win"&lt;&lt;endl; print_ans(i,1); return 0; &#125; memset(c,0,sizeof c); if(huan(s)) puts("Draw"); else puts("Lose"); return 0;&#125;]]></content>
      <categories>
        <category>2018暑假集训</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>图论</tag>
        <tag>hash</tag>
        <tag>二分</tag>
        <tag>找规律</tag>
        <tag>拆点</tag>
        <tag>折半查找</tag>
      </tags>
  </entry>
</search>
